[["tidy-rna-seq-eda.html", "Chapter 7 Tidy RNA-seq EDA", " Chapter 7 Tidy RNA-seq EDA Objective: learn how to make basic EDA plots (plotting scaled counts) of RNA-seq data using tidy-style verbs. The tidybulk Bioconductor package and associated tidy transcriptomics ecosystem (tidySummarizedExperiment, tidySingleCell, tidyseurat, etc.) provide a bridge between the SummarizedExperiment-style representation of matrix data with attached metadata, to the tidy-style representation of data (one row per observation). For more details on the package, check out the tidybulk website, and the publication: Mangiola et al. (2021). Here we will briefly examine the difference between tidy manipulation of these matrix-style objects compared to how these objects would be manipulated in other Bioconductor workflows (e.g. DESeq2, edgeR, or limma workflows). As you will see, there are multiple ways to generate the same or similar exploratory plots and analyses. we recommend to consider which is more appropriate to your purpose. For package code, you may prefer to have fewer dependencies, going with core Bioconductor objects and packages. For scripting, the “fluent” and piped style of tidybulk may be preferable, and easier for others to read and modify your code at a future date. Here we just compare code for some basic tasks, scaling counts and performing DE with DESeq2. However, note that tidybulk has many functionalities implemented, including dimension reduction and visualization (PCA, MDS, tSNE, UMAP), clustering, gene set testing, cell type composition analysis and cell abundance testing, unwanted variation modeling, imputation, etc. Start by loading this RNA-seq dataset from the following paper: King and Klose (2017) “The pioneer factor OCT4 requires the chromatin remodeller BRG1 to support gene regulatory element function in mouse embryonic stem cells” https://doi.org/10.7554/eLife.22631. The experiment focused on OCT4 as it is a “core pluripotency transcription factor” which “occupies sites that would otherwise be inaccessible and is required to shape the occupancy of additional pluripotency transcription factors.” In this experiment, transcription in mouse embryonic stem cells (ESC) was compared with and without OCT4. This was done using a conditional mouse ESC line where treatment with a compound leads to loss of OCT4 expression. The experiment also involved the same approach to another transcription factor BRG1, but we focus here on the OCT4 samples. First we load the metadata about the samples: library(oct4) dir &lt;- system.file(&quot;extdata&quot;, package=&quot;oct4&quot;) coldata &lt;- read.csv(file.path(dir,&quot;coldata.csv&quot;)) coldata ## names line condition ## 1 SRX2236945 OCT4 untrt ## 2 SRX2236946 OCT4 untrt ## 3 SRX2236947 OCT4 untrt ## 4 SRX2236948 OCT4 trt ## 5 SRX2236949 OCT4 trt ## 6 SRX2236950 OCT4 trt ## 7 SRX2236951 BRG1 untrt ## 8 SRX2236952 BRG1 untrt ## 9 SRX2236953 BRG1 untrt ## 10 SRX2236954 BRG1 trt ## 11 SRX2236955 BRG1 trt ## 12 SRX2236956 BRG1 trt coldata$files &lt;- file.path(dir, &quot;quants&quot;, coldata$names, &quot;quant.sf.gz&quot;) Read in the count data with tximeta, which automatically imports the information about the gene provenance (which transcripts were used to quantify the gene and isoform abundance). We then summarize the quantification to the gene-level, and add the gene SYMBOL. library(tximeta) se &lt;- tximeta(coldata) gse &lt;- summarizeToGene(se) library(org.Mm.eg.db) gse &lt;- addIds(gse, &quot;SYMBOL&quot;) For this workflow, we don’t need the inferential replicates (about uncertainty regarding the quantification), so we keep just the counts, abundances (TPM), and gene lengths. We also manipulate the metadata a little bit. library(SummarizedExperiment) assayNames(gse) assays(gse) &lt;- assays(gse)[1:3] gse$rep &lt;- rep(1:3, 4) colnames(gse) &lt;- paste(gse$line,gse$condition,gse$rep,sep=&quot;-&quot;) assay(gse, &quot;counts&quot;) &lt;- round(assay(gse, &quot;counts&quot;)) # for DE consistency # save for easy loading later save(gse, file=&quot;data/oct4_obj.rda&quot;) library(SummarizedExperiment) load(&quot;data/oct4_obj.rda&quot;) The dataset looks like this (remember it has untreated and treated samples for both OCT4 and BRG1). gse ## class: RangedSummarizedExperiment ## dim: 53697 12 ## metadata(6): tximetaInfo quantInfo ... txomeInfo txdbInfo ## assays(3): counts abundance length ## rownames(53697): ENSMUSG00000000001.4 ENSMUSG00000000003.15 ... ENSMUSG00000117654.1 ## ENSMUSG00000117655.1 ## rowData names(3): gene_id tx_ids SYMBOL ## colnames(12): OCT4-untrt-1 OCT4-untrt-2 ... BRG1-trt-2 BRG1-trt-3 ## colData names(4): names line condition rep We will be interested in the gene set from the Gene Ontology project, which describes maintenance of pluripotency. We can extra this from the mouse organism data package with the following three lines of code: library(AnnotationDbi) library(org.Mm.eg.db) ## # pluripotency tab &lt;- select(org.Mm.eg.db, &quot;GO:0019827&quot;, &quot;SYMBOL&quot;, &quot;GO&quot;) ## &#39;select()&#39; returned 1:many mapping between keys and columns tab &lt;- tab[!duplicated(tab$SYMBOL),] pluri &lt;- tab$SYMBOL Now we start with tidybulk code, comparing in turn to base R. We filter the samples that correspond to the OCT4 experiment, and then modify the sample names. Samples are referred to with the special .sample string, while features are referred to with .feature, so here we create a new variable to plot the samples sample_name. library(tidybulk) library(tidySummarizedExperiment) library(dplyr) library(stringr) oct4 &lt;- gse %&gt;% tidybulk() %&gt;% filter(line == &quot;OCT4&quot;) %&gt;% mutate(sample_name = .sample %&gt;% str_remove(&quot;OCT4-&quot;) %&gt;% factor(levels = unique(.)), condition = condition %&gt;% factor(c(&quot;untrt&quot;,&quot;trt&quot;))) Note, the third line in the mutate call uses the unique function to set the levels: the consequence of this is that the sample_name factor will have levels in the order in which they are present in the current character vector and not alphabetical. oct4 ## # A tibble: 322,182 × 18 ## .feature .sample counts abund…¹ length names line condi…² rep gene_id tx_ids SYMBOL seqna…³ ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; &lt;int&gt; &lt;chr&gt; &lt;name&gt; &lt;chr&gt; &lt;fct&gt; ## 1 ENSMUSG000… OCT4-u… 2920 16.6 2953. SRX2… OCT4 untrt 1 ENSMUS… &lt;chr&gt; Gnai3 chr3 ## 2 ENSMUSG000… OCT4-u… 0 0 589. SRX2… OCT4 untrt 1 ENSMUS… &lt;chr&gt; Pbsn chrX ## 3 ENSMUSG000… OCT4-u… 1906 19.0 1688. SRX2… OCT4 untrt 1 ENSMUS… &lt;chr&gt; Cdc45 chr16 ## 4 ENSMUSG000… OCT4-u… 9044 74.8 2034. SRX2… OCT4 untrt 1 ENSMUS… &lt;chr&gt; H19 chr7 ## 5 ENSMUSG000… OCT4-u… 132 0.826 2688. SRX2… OCT4 untrt 1 ENSMUS… &lt;chr&gt; Scml2 chrX ## 6 ENSMUSG000… OCT4-u… 0 0 943. SRX2… OCT4 untrt 1 ENSMUS… &lt;chr&gt; Apoh chr11 ## 7 ENSMUSG000… OCT4-u… 444 1.84 4062. SRX2… OCT4 untrt 1 ENSMUS… &lt;chr&gt; Narf chr11 ## 8 ENSMUSG000… OCT4-u… 8 0.0554 2430. SRX2… OCT4 untrt 1 ENSMUS… &lt;chr&gt; Cav2 chr6 ## 9 ENSMUSG000… OCT4-u… 2503 16.3 2588. SRX2… OCT4 untrt 1 ENSMUS… &lt;chr&gt; Klf6 chr13 ## 10 ENSMUSG000… OCT4-u… 610 7.58 1354. SRX2… OCT4 untrt 1 ENSMUS… &lt;chr&gt; Scmh1 chr4 ## # … with 322,172 more rows, 5 more variables: start &lt;int&gt;, end &lt;int&gt;, width &lt;int&gt;, strand &lt;fct&gt;, ## # sample_name &lt;fct&gt;, and abbreviated variable names ¹​abundance, ²​condition, ³​seqnames tidybulk provides access to many steps in bulk analysis, including filtering and count scaling. For details on what is happening behind the scene, see the help, e.g. ?keep_abundant describes that it makes use of edgeR::filterByExpr. oct4 &lt;- oct4 %&gt;% keep_abundant(factor_of_interest = condition) %&gt;% scale_abundance(method=&quot;RLE&quot;) # DESeq2 scaling ## tidybulk says: the sample with largest library size OCT4-untrt-1 was chosen as reference for scaling It is straightforward to pipe the data directly into plots: library(ggplot2) oct4 %&gt;% ggplot(aes(sample_name, counts_scaled + 1)) + geom_boxplot() + scale_y_log10() For comparing code, let’s pull out the genes that remain: gene_idx &lt;- oct4 %&gt;% pivot_transcript() %&gt;% pull(.feature) head(gene_idx) ## [1] &quot;ENSMUSG00000000001.4&quot; &quot;ENSMUSG00000000028.15&quot; &quot;ENSMUSG00000000031.16&quot; &quot;ENSMUSG00000000037.16&quot; ## [5] &quot;ENSMUSG00000000056.7&quot; &quot;ENSMUSG00000000058.6&quot; The equivalent code in DESeq2. Understanding this code requires knowledge that boxplot plots columns of a matrix. library(DESeq2) gse_sub &lt;- gse[ gene_idx , gse$line == &quot;OCT4&quot; ] gse_sub$condition &lt;- factor(gse_sub$condition) dds &lt;- gse_sub %&gt;% DESeqDataSet(~condition) %&gt;% estimateSizeFactors() ## using counts and average transcript lengths from tximeta ## using &#39;avgTxLength&#39; from assays(dds), correcting for library size boxplot(counts(dds, normalized=TRUE) + 1, log=&quot;y&quot;) We can also make more interesting plots. E.g. for the genes involved in pluripotency, make a line plot, highlighting OCT4. In addition, center the log counts for each gene (subtract the mean of log counts across samples). oct4 %&gt;% filter(SYMBOL %in% pluri) %&gt;% mutate(logcounts = log10(counts_scaled + 1)) %&gt;% mutate(Oct4 = ifelse(SYMBOL == &quot;Pou5f1&quot;, &quot;red&quot;, &quot;black&quot;)) %&gt;% group_by(.feature) %&gt;% mutate(logcounts = logcounts - mean(logcounts)) %&gt;% ungroup() %&gt;% ggplot(aes(sample_name, logcounts, group=.feature, color=Oct4)) + geom_point() + geom_line() + scale_color_identity() The equivalent code for base R requires defining more intermediate variables and control flow code (the for loop). While there’s nothing particularly right or wrong about the two choices, the above prioritizes the operations in a way that is human readable. In some cases, e.g. performing linear algebra operations on matrices, base R code may prove to be more efficient, which is a consideration for what to use in package source code. pluri_idx &lt;- mcols(dds)$SYMBOL %in% pluri mat &lt;- log10(counts(dds, normalized=TRUE)[pluri_idx,] + 1) mat &lt;- mat - rowMeans(mat) hilite &lt;- rownames(dds)[which(mcols(dds)$SYMBOL == &quot;Pou5f1&quot;)] plot(mat[1,], type=&quot;n&quot;, ylim=c(-1,1), xlab=&quot;samples&quot;, ylab=&quot;logcounts&quot;) for (i in 1:nrow(mat)) { col &lt;- ifelse(rownames(mat)[i] == hilite, &quot;red&quot;, &quot;black&quot;) points(mat[i,], type=&quot;b&quot;, col=col) } We can test for differential expression with DESeq2: assays(dds) &lt;- assays(dds)[1:2] # for DE consistency res &lt;- dds[gene_idx,] %&gt;% DESeq(quiet=TRUE) %&gt;% results() Or equivalently with tidybulk: oct4 &lt;- oct4 %&gt;% test_differential_abundance(~condition, method=&quot;deseq2&quot;, quiet=TRUE) ## ===================================== ## tidybulk says: All testing methods use raw counts, irrespective of if scale_abundance ## or adjust_abundance have been calculated. Therefore, it is essential to add covariates ## such as batch effects (if applicable) in the formula. ## ===================================== ## tidybulk says: to access the raw results (fitted GLM) do `attr(..., &quot;internals&quot;)$DESeq2` ## This message is displayed once per session. tidy_res &lt;- oct4 %&gt;% pivot_transcript() Because we have filtered the two objects identically, we obtain the same test results: all.equal(rownames(res), tidy_res$.feature) ## [1] TRUE table(base_sig = res$padj &lt; .1, tidy_sig = tidy_res$padj &lt; .1) ## tidy_sig ## base_sig FALSE TRUE ## FALSE 17743 0 ## TRUE 0 3734 Finally, we build up to a more interesting plot. Suppose we now want to split the genes involved in pluripotency by the DE result (the significance and LFC), and then add the gene symbol to the side. We begin by building the dataset: plot_data &lt;- oct4 %&gt;% filter(SYMBOL %in% pluri) %&gt;% mutate(logcounts = log10(counts_scaled + 1)) %&gt;% mutate(Oct4 = ifelse(SYMBOL == &quot;Pou5f1&quot;, &quot;red&quot;, &quot;black&quot;)) %&gt;% group_by(.feature) %&gt;% mutate(logcounts = logcounts - mean(logcounts)) %&gt;% ungroup() %&gt;% mutate(gene_type = case_when( padj &lt; .1 &amp; log2FoldChange &gt; 0 ~ &quot;up&quot;, padj &lt; .1 &amp; log2FoldChange &lt; 0 ~ &quot;down&quot;, TRUE ~ &quot;null&quot;)) Now we repeat the code from before, but now faceting by gene_type. Furthermore, we use geom_text_repel to add labels to the right side. library(ggrepel) plot_data %&gt;% filter(gene_type != &quot;null&quot;) %&gt;% ggplot(aes(sample_name, logcounts, group=.feature, color=Oct4)) + geom_point() + geom_line() + geom_text_repel(data=plot_data %&gt;% filter(sample_name == &quot;trt-3&quot;, gene_type != &quot;null&quot;), aes(sample_name, logcounts, label=SYMBOL), nudge_x=.5, seed=1) + scale_color_identity() + facet_wrap(~gene_type) + scale_x_discrete(expand = expansion(add = 2)) + xlab(&quot;sample&quot;) ## Warning: ggrepel: 8 unlabeled data points (too many overlaps). Consider increasing max.overlaps References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
