[["index.html", "Tidy Ranges Tutorial About", " Tidy Ranges Tutorial Michael Love 2023-07-04 About I provide examples of computing operations on genomic ranges using the tidy data philosophy. These examples focus on the packages dplyr, plyranges, nullranges, excluderanges, as well as tidy transcriptomics packages such as tidybulk and tidySummarizedExperiment. "],["join-is-an-overlap.html", "Chapter 1 Join is an overlap", " Chapter 1 Join is an overlap Objective: learn that a “join” is like an overlap. We start with a quick example explaining why we use functions called join. library(dplyr) library(tidyr) library(randomNames) Let’s set up a simulation where we have 17 classmates (not counting ourselves) in a school of 118. Suppose every member of the class has 12 friends outside of class. We want to find out, for each classmate, how many friends we have in common and also, of our shared friends, what is a typical birthday. Let’s define typical as the median birthday of our shared friends. m &lt;- 17 # size of class n &lt;- 100 # size of others in school nf &lt;- 12 # number of friends outside class set.seed(5) people &lt;- randomNames(m + n, name.order=&quot;first.last&quot;, name.sep=&quot; &quot;) We define the population of potential friends (those outside the class) as pop, and our 12 friends are in friends. Finally, we define the people that are in our class as class_people. pop &lt;- data.frame(person=people[-(1:m)], birthday=sample(31, n, TRUE)) friends &lt;- data.frame(friend=sample(people, nf)) class_people &lt;- people[1:m] The following sets up a data.frame, where each row gives, for a given classmate, their friends, and the friends’ birthdays. loop &lt;- rep(1:m, each=nf) idx &lt;- as.vector(replicate(m, sample(n, nf))) class &lt;- data.frame(classmate=class_people[loop], friend=pop$person[idx], birthday=pop$birthday[idx]) Sort this by classmate alphabetically, and make classmate into a factor. This last step is important, as it will help us to keep track of the classmates for whom we share no friends outside of class. class &lt;- class %&gt;% arrange(classmate) %&gt;% mutate(classmate=factor(classmate)) We perform an inner_join by \"friend\". This just means we look for classmates where we have overlapping friends, and we drop the rows where we don’t share any friends. “Inner” refers to the fact that we are keeping the overlap in the inside of two intersecting circles. Note that the join operation brings along the metadata (extra data) about the friends’ birthdays. shared_friends &lt;- friends %&gt;% inner_join(class, by=&quot;friend&quot;) %&gt;% arrange(classmate, friend) %&gt;% relocate(classmate) # classmate to 1st column shared_friends ## classmate friend birthday ## 1 Brandon Jones Christopher Rivera 13 ## 2 Brandon Jones Jose Jimenez 26 ## 3 Brandon Jones Maria Hernandez 15 ## 4 Brandon Jones Tuli Hoang 7 ## 5 Christopher Herron Tuli Hoang 7 ## 6 Christopher Herron William Steinbach 15 ## 7 Haley Polhamus Cellene Millhone 23 ## 8 Haley Polhamus William Steinbach 15 ## 9 Juan Villegas Cabrera Alyssa Kinanee 30 ## 10 Juan Villegas Cabrera Malik Gammon 5 ## 11 Juan Villegas Cabrera Tajhae Bohanna 31 ## 12 Maisara el-Arshad Kaylyn Judkins 2 ## 13 Maisara el-Arshad Maria Hernandez 15 ## 14 Maisara el-Arshad Tajhae Bohanna 31 ## 15 Michael Mcgill Christopher Rivera 13 ## 16 Michael Mcgill Maria Hernandez 15 ## 17 Noah Pettinger Kaylyn Judkins 2 ## 18 Noah Pettinger Tajhae Bohanna 31 ## 19 Orion Villani Malik Gammon 5 ## 20 Shane Ranaldi Alyssa Kinanee 30 ## 21 Shane Ranaldi William Steinbach 15 ## 22 Stephanie Hernandez Asmaa el-Abdelnour 29 ## 23 Zachary Roe-Huffman Maria Hernandez 15 Lastly, we perform some summarization: compute the number of friends in common with n() and the median birthday of shared friends. The complete call at the end fills in 0 for those classmates for whom we share no friends (here, the use of factor earlier becomes relevant). We can choose which columns to fill in, and what value to add. shared_friends %&gt;% group_by(classmate) %&gt;% summarize(in_common=n(), median_bday=median(birthday)) %&gt;% complete(classmate, fill=list(in_common=0,median_bday=-1)) ## # A tibble: 17 × 3 ## classmate in_common median_bday ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Aaliyah Minter 0 -1 ## 2 Brandon Jones 4 14 ## 3 Christopher Herron 2 11 ## 4 Collin Leon 0 -1 ## 5 Haley Polhamus 2 19 ## 6 Juan Villegas Cabrera 3 30 ## 7 Khaalid el-Ammar 0 -1 ## 8 Kianna Mcalevy 0 -1 ## 9 Maazin al-Ismael 0 -1 ## 10 Maisara el-Arshad 3 15 ## 11 Michael Mcgill 2 14 ## 12 Noah Pettinger 2 16.5 ## 13 Orion Villani 1 5 ## 14 Shane Ranaldi 2 22.5 ## 15 Stephanie Hernandez 1 29 ## 16 Xavier Urueta 0 -1 ## 17 Zachary Roe-Huffman 1 15 "],["compute-overlaps.html", "Chapter 2 Compute overlaps", " Chapter 2 Compute overlaps Objective: compute overlaps and summary statistics between two sets of genomic ranges. In particular, suppose we want to compute the mean genomic extent (distance from left-most to right-most basepair) of genes overlapping a set of query ranges. We move on from the “classroom example” by seeing how we compute overlaps when the features are in genomic space. We will use GRanges in the Bioconductor package GenomicRanges (Lawrence et al. 2013) to represent the features and plyranges (Lee, Cook, and Lawrence 2019) to compute the overlaps, similarly to how we used dplyr to compute the overlaps in the previous analysis. So data.frame is to dplyr as GRanges is to plyranges. library(plyranges) Note the structure of the GRanges object. We can create a GRanges from a data.frame by specifying two of: start, end, or width. df &lt;- data.frame( seqnames=&quot;chr1&quot;, start=1 + c(34e6,36e6,36.6e6), width=c(2e5,2e5,1e5), strand=c(&quot;+&quot;,&quot;-&quot;,&quot;-&quot;), range_id=factor(c(&quot;foo&quot;,&quot;bar&quot;,&quot;boo&quot;))) r &lt;- as_granges(df) r ## GRanges object with 3 ranges and 1 metadata column: ## seqnames ranges strand | range_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; ## [1] chr1 34000001-34200000 + | foo ## [2] chr1 36000001-36200000 - | bar ## [3] chr1 36600001-36700000 - | boo ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths In case you haven’t seen this before, GRanges objects have specific functions to pull out information. See ?GRanges for details. length(r) ## [1] 3 seqnames(r) ## factor-Rle of length 3 with 1 run ## Lengths: 3 ## Values : chr1 ## Levels(1): chr1 strand(r) ## factor-Rle of length 3 with 2 runs ## Lengths: 1 2 ## Values : + - ## Levels(3): + - * Let’s use plyranges to find the genes that overlap a region of interest. Typically, it is prefered to use Ensembl or GENCODE gene annotation, the latter of which can by obtained from AnnotationHub. Ensembl gene annotation can be easily manipulated with the ensembldb package (Rainer, Gatto, and Weichenberger 2019). Provided is some example code in an unevaluated code chunk: library(ensembldb) edb &lt;- ... # obtain from AnnotationHub or from GTF file g &lt;- genes(edb) Here, we will work with a static TxDb that is distributed as an annotation package in Bioconductor. We use this TxDb because it is an older genome release (hg19) that matches some ranges we will work with later, but generally it is recommended to use a recent (and versioned) Ensembl or GENCODE gene annotation. library(TxDb.Hsapiens.UCSC.hg19.knownGene) The same function can be used to extract the gene ranges: g &lt;- genes(TxDb.Hsapiens.UCSC.hg19.knownGene) ## 403 genes were dropped because they have exons located on both strands of the same ## reference sequence or on more than one reference sequence, so cannot be represented by a ## single genomic range. ## Use &#39;single.strand.genes.only=FALSE&#39; to get all the genes in a GRangesList object, or use ## suppressMessages() to suppress this message. g &lt;- keepStandardChromosomes(g, pruning.mode=&quot;coarse&quot;) g ## GRanges object with 23033 ranges and 1 metadata column: ## seqnames ranges strand | gene_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; ## 1 chr19 58858172-58874214 - | 1 ## 10 chr8 18248755-18258723 + | 10 ## 100 chr20 43248163-43280376 - | 100 ## 1000 chr18 25530930-25757445 - | 1000 ## 10000 chr1 243651535-244006886 - | 10000 ## ... ... ... ... . ... ## 9991 chr9 114979995-115095944 - | 9991 ## 9992 chr21 35736323-35743440 + | 9992 ## 9993 chr22 19023795-19109967 - | 9993 ## 9994 chr6 90539619-90584155 + | 9994 ## 9997 chr22 50961997-50964905 - | 9997 ## ------- ## seqinfo: 25 sequences (1 circular) from hg19 genome Now we are ready to test for overlaps. A left join gives us all the overlaps for ranges on the left side (here r). If a range on the left has no overlaps it appears with NA for the metadata columns of the right side ranges. If a range on the left side has multiple overlaps with the right side, it will appear multiple times in the output. Keeping reading below on how to deal with this, if it is desired to have statistics on per-range overlaps. r %&gt;% join_overlap_left(g) ## GRanges object with 10 ranges and 2 metadata columns: ## seqnames ranges strand | range_id gene_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;character&gt; ## [1] chr1 34000001-34200000 + | foo 114784 ## [2] chr1 36000001-36200000 - | bar 127703 ## [3] chr1 36000001-36200000 - | bar 23154 ## [4] chr1 36000001-36200000 - | bar 339488 ## [5] chr1 36000001-36200000 - | bar 5690 ## [6] chr1 36000001-36200000 - | bar 63967 ## [7] chr1 36000001-36200000 - | bar 79932 ## [8] chr1 36600001-36700000 - | boo 27095 ## [9] chr1 36600001-36700000 - | boo 55700 ## [10] chr1 36600001-36700000 - | boo 9967 ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths If we want to exclude the zero matches cases, we can use an inner join: r %&gt;% join_overlap_inner(g) ## GRanges object with 10 ranges and 2 metadata columns: ## seqnames ranges strand | range_id gene_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;character&gt; ## [1] chr1 34000001-34200000 + | foo 114784 ## [2] chr1 36000001-36200000 - | bar 127703 ## [3] chr1 36000001-36200000 - | bar 23154 ## [4] chr1 36000001-36200000 - | bar 339488 ## [5] chr1 36000001-36200000 - | bar 5690 ## [6] chr1 36000001-36200000 - | bar 63967 ## [7] chr1 36000001-36200000 - | bar 79932 ## [8] chr1 36600001-36700000 - | boo 27095 ## [9] chr1 36600001-36700000 - | boo 55700 ## [10] chr1 36600001-36700000 - | boo 9967 ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths What about other types of overlap? Note that we can specify a distance, called a “gap,” if we want to also find when ranges are near each other, up to a maximum allowed distance. We can also specify the minimum amount of overlapping basepairs. Every overlap function in plyranges has arguments maxgap and minoverlap. For example, to see if ranges are 50kb from each other, we would specify maxgap=5e4. If we want to know if ranges are 50kb from a particular endpoint of another set of ranges, for example TSS, we could perform the operations anchor_5p() followed by mutate(width=1), before overlapping the sets. We can also perform summarization by columns either in the r or the g object: r %&gt;% join_overlap_inner(g) %&gt;% group_by(range_id) %&gt;% summarize(count=n()) ## DataFrame with 3 rows and 2 columns ## range_id count ## &lt;factor&gt; &lt;integer&gt; ## 1 bar 6 ## 2 boo 3 ## 3 foo 1 This is giving us the same information as the following: r %&gt;% count_overlaps(g) ## [1] 1 6 3 Which can be added to the range data with a mutate call: r %&gt;% mutate(overlaps = count_overlaps(., g)) ## GRanges object with 3 ranges and 2 metadata columns: ## seqnames ranges strand | range_id overlaps ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;integer&gt; ## [1] chr1 34000001-34200000 + | foo 1 ## [2] chr1 36000001-36200000 - | bar 6 ## [3] chr1 36600001-36700000 - | boo 3 ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths If we don’t care about multiple overlaps, but just want a binary variable that records if there was one or more overlaps or not, we can ask if the count of overlaps is greater than 0: r %&gt;% mutate(overlaps_any = count_overlaps(., g) &gt; 0) ## GRanges object with 3 ranges and 2 metadata columns: ## seqnames ranges strand | range_id overlaps_any ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;logical&gt; ## [1] chr1 34000001-34200000 + | foo TRUE ## [2] chr1 36000001-36200000 - | bar TRUE ## [3] chr1 36600001-36700000 - | boo TRUE ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths If we want to keep the information about the gene ranges, we swap the order of the ranges in the command: g %&gt;% join_overlap_inner(r) ## GRanges object with 10 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id range_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;factor&gt; ## 114784 chr1 33979609-34631443 - | 114784 foo ## 127703 chr1 36179477-36184790 - | 127703 bar ## 23154 chr1 36023393-36032380 + | 23154 bar ## 27095 chr1 36602170-36621654 - | 27095 boo ## 339488 chr1 36038971-36060927 + | 339488 bar ## 55700 chr1 36621803-36646441 + | 55700 boo ## 5690 chr1 36035413-36107445 - | 5690 bar ## 63967 chr1 36197713-36235551 - | 63967 bar ## 79932 chr1 35899091-36023551 - | 79932 bar ## 9967 chr1 36690017-36770957 + | 9967 boo ## ------- ## seqinfo: 25 sequences (1 circular) from hg19 genome If we want strand specific overlaps, we can add _directed: g %&gt;% join_overlap_inner_directed(r) ## GRanges object with 5 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id range_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;factor&gt; ## 127703 chr1 36179477-36184790 - | 127703 bar ## 27095 chr1 36602170-36621654 - | 27095 boo ## 5690 chr1 36035413-36107445 - | 5690 bar ## 63967 chr1 36197713-36235551 - | 63967 bar ## 79932 chr1 35899091-36023551 - | 79932 bar ## ------- ## seqinfo: 25 sequences (1 circular) from hg19 genome By turning the join around, we have access to the genomic range information about the genes. Now we can compute, e.g. the average genomic extent of the genes (first base to last base), per overlapping range. g %&gt;% join_overlap_inner_directed(r) %&gt;% group_by(range_id) %&gt;% summarize(count=n(), mean_width=mean(width)) ## DataFrame with 2 rows and 3 columns ## range_id count mean_width ## &lt;factor&gt; &lt;integer&gt; &lt;numeric&gt; ## 1 bar 4 59911.8 ## 2 boo 1 19485.0 What about \"foo\"? We need to add a complete() call to account for the fact that we are missing those overlaps after the join. We need to call the function explicitly from the tidyr package but by not loading the package we can avoid some function name conflicts with plyranges. Also we need to convert to tibble (explanation follows). library(tibble) g %&gt;% join_overlap_inner_directed(r) %&gt;% group_by(range_id) %&gt;% summarize(count=n(), mean_width=mean(width)) %&gt;% as_tibble() %&gt;% tidyr::complete(range_id, fill=list(count=0)) ## # A tibble: 3 × 3 ## range_id count mean_width ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 bar 4 59912. ## 2 boo 1 19485 ## 3 foo 0 NA Why did we have to convert to tibble before running complete()? This is because metadata columns of GRanges objects are in a format called DataFrame, on which the tidyr / dplyr functions don’t know how to operate. To access metadata columns of a GRanges object, you can use any of these paradigms: mcols(r) ## DataFrame with 3 rows and 1 column ## range_id ## &lt;factor&gt; ## 1 foo ## 2 bar ## 3 boo mcols(r)$range_id ## [1] foo bar boo ## Levels: bar boo foo r$range_id # this works also ## [1] foo bar boo ## Levels: bar boo foo mcols(r)[[&quot;range_id&quot;]] # for programmatic access ## [1] foo bar boo ## Levels: bar boo foo But if you want to work on them in with tidyr / dplyr, you need to first convert to tibble (or data.frame): mcols(r) %&gt;% as_tibble() ## # A tibble: 3 × 1 ## range_id ## &lt;fct&gt; ## 1 foo ## 2 bar ## 3 boo Reduce instead of summarize: Above when we used group_by and summarize we lost the original range data. Another option, to preserve the range data, is to use the function reduce_ranges within groups that we define (which can be _directed or not). If we want to preserve the range information for the r object, we can start with r and proceed to join, group by, and reduce within groups. For an example of reduce_ranges used in the context of a genomic data analysis see Lee, Lawrence, and Love (2020). In order to compute on the gene widths, we have to add that as a metadata column within the join. To keep the no-gene-overlapping ranges in r, we can count when the gene ID is not NA. r %&gt;% join_overlap_left_directed(g %&gt;% mutate(gene_width=width)) %&gt;% group_by(range_id) %&gt;% reduce_ranges(count=sum(!is.na(gene_id)), mean_width=mean(gene_width)) ## GRanges object with 3 ranges and 3 metadata columns: ## seqnames ranges strand | range_id count mean_width ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;integer&gt; &lt;numeric&gt; ## [1] chr1 34000001-34200000 * | foo 0 NA ## [2] chr1 36000001-36200000 * | bar 4 59911.8 ## [3] chr1 36600001-36700000 * | boo 1 19485.0 ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths Hopefully, you’ve seen that there are many routes to compute the types of statistics of interest. The best way to decide which one to use is to think first: what do I want the final output to look like, and do I need to keep track of non-overlapping ranges? This will help dictate the way you set up your code, whether a join or a mutate to just tally a column of overlaps, etc., and whether a complete call is needed to fill in missing levels at the end of the analysis. References "],["promoter-marks.html", "Chapter 3 Promoter marks", " Chapter 3 Promoter marks Objective: determine if tissue-specific promoter marks (e.g. H3K27ac) are often near genes that are expressed in a tissue-specific manner. We will load expression data from the GTEx project (Lonsdale and others 2013), which gives median expression in TPM for each tissue. We will use H3K27ac ChIP-seq data from the ENCODE project (Dunham and others 2012). library(tidyr) file &lt;- &quot;data/GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_median_tpm.gct.gz&quot; gtex &lt;- read.delim(file, skip=2) We select two tissues, bladder and kidney, and convert the data from a wide format into a tidy format. tissues &lt;- gtex %&gt;% dplyr::select(Name, Bladder, Kidney...Cortex) %&gt;% dplyr::rename(gene = Name, Kidney = Kidney...Cortex) %&gt;% dplyr::mutate(gene = sub(&quot;\\\\..*&quot;,&quot;&quot;,gene)) %&gt;% pivot_longer(!gene, names_to=&quot;tissue&quot;, values_to=&quot;tpm&quot;) Now define two vectors of genes that are specific to bladder and kidney: bladder_expr &lt;- tissues %&gt;% dplyr::filter(tissue == &quot;Bladder&quot; &amp; tpm &gt; 10) %&gt;% dplyr::pull(gene) kidney_expr &lt;- tissues %&gt;% dplyr::filter(tissue == &quot;Kidney&quot; &amp; tpm &gt; 10) %&gt;% dplyr::pull(gene) int &lt;- intersect(bladder_expr, kidney_expr) bladder_expr &lt;- setdiff(bladder_expr, int) kidney_expr &lt;- setdiff(kidney_expr, int) # save(bladder_expr, kidney_expr, file=&quot;data/bladder_kidney_expr.rda&quot;) Next, use an existing TxDb to locate these genes in the genomes. While we usually recommend to use GENCODE genes for human analysis, because the ENCODE chromatin modification peak files on AnnotationHub are in hg19, we use the UCSC hg19 genes here for simplicity of the code: library(TxDb.Hsapiens.UCSC.hg19.knownGene) library(org.Hs.eg.db) Add the ENSEMBL ID and pull out the two tissue-specific sets. g &lt;- genes(TxDb.Hsapiens.UCSC.hg19.knownGene) ## 403 genes were dropped because they have exons located on both strands of the same ## reference sequence or on more than one reference sequence, so cannot be represented by a ## single genomic range. ## Use &#39;single.strand.genes.only=FALSE&#39; to get all the genes in a GRangesList object, or use ## suppressMessages() to suppress this message. library(plyranges) g &lt;- g %&gt;% mutate(ensembl = mapIds(org.Hs.eg.db, gene_id, &quot;ENSEMBL&quot;, &quot;ENTREZID&quot;)) bladder_g &lt;- g %&gt;% filter(ensembl %in% bladder_expr) kidney_g &lt;- g %&gt;% filter(ensembl %in% kidney_expr) Finally we combine the two sets with bind_ranges, and we change the feature size from the whole gene extent (the range from the leftmost exon to rightmost exon), to just the TSS, using anchor_5p and mutate. tss &lt;- bind_ranges(bladder=bladder_g, kidney=kidney_g, .id=&quot;gtissue&quot;) %&gt;% anchor_5p() %&gt;% mutate(width=1) Now we will obtain the H3K27ac peak sets: library(AnnotationHub) ah &lt;- AnnotationHub() # query(ah, c(&quot;Homo sapiens&quot;, &quot;bladder&quot;, &quot;H3K27ac&quot;, &quot;narrowPeak&quot;)) bladder_pks &lt;- ah[[&quot;AH44180&quot;]] # query(ah, c(&quot;Homo sapiens&quot;, &quot;kidney&quot;, &quot;H3K27ac&quot;, &quot;narrowPeak&quot;)) kidney_pks &lt;- ah[[&quot;AH43443&quot;]] save(bladder_pks, kidney_pks, file=&quot;data/peaks.rda&quot;) We download these and scale so they have the same 90% quantile of signalValue. ninety &lt;- function(x) quantile(x, .9, names=FALSE) bladder_pks &lt;- bladder_pks %&gt;% mutate(signal = signalValue / ninety(signalValue)) kidney_pks &lt;- kidney_pks %&gt;% mutate(signal = signalValue / ninety(signalValue)) Combine the peaks from bladder and kidney, filter to those with &lt; 0.1% FDR, and center the peak on the summit (the peak column gives the shift from the left side to the summit). pks &lt;- bind_ranges(bladder=bladder_pks, kidney=kidney_pks, .id=&quot;ptissue&quot;) %&gt;% filter(qValue &gt; 3, width &lt;= 1000) %&gt;% mutate(start = start + peak) %&gt;% select(-peak) %&gt;% mutate(width = 1) Finally, once we have two tidy range sets, we can perform the analysis by a join, followed by two lines that take care of multiple overlaps, followed by two lines that give us our tallies of interest. It appears that tissue-specific peaks are enriched near the tissue-specific genes for both bladder and kidney. tss %&gt;% join_overlap_left(pks, maxgap=500) %&gt;% group_by(ptissue) %&gt;% # within peak tissue... filter(!duplicated(gene_id)) %&gt;% # ...just take the first overlap per gene group_by(gtissue, ptissue) %&gt;% summarize(count = n()) ## DataFrame with 6 rows and 3 columns ## gtissue ptissue count ## &lt;Rle&gt; &lt;character&gt; &lt;integer&gt; ## 1 bladder bladder 2163 ## 2 bladder kidney 1568 ## 3 bladder NA 859 ## 4 kidney bladder 103 ## 5 kidney kidney 208 ## 6 kidney NA 242 The above number could also be found with four countOverlaps calls, by considering all four pairs of overlaps of the two sets of genes and peaks. Another way to avoid counting overlaps more than once per gene is to use the plyranges function, n_distinct(): tss %&gt;% join_overlap_left(pks, maxgap=500) %&gt;% group_by(gtissue, ptissue) %&gt;% summarize(count = n_distinct(gene_id)) ## DataFrame with 6 rows and 3 columns ## gtissue ptissue count ## &lt;Rle&gt; &lt;character&gt; &lt;integer&gt; ## 1 bladder bladder 2163 ## 2 bladder kidney 1568 ## 3 bladder NA 859 ## 4 kidney bladder 103 ## 5 kidney kidney 208 ## 6 kidney NA 242 If we want more information per gene, e.g. suppose we want to compute the average signal per gene of peaks nearby, we need to group twice, once also by gene ID, and the second time integrating over gene ID. While here we add a few more lines of code, performing such an operation with base Bioconductor functions would require adding code to perform the loops, adding many intermediate variables to store results, etc. tss %&gt;% join_overlap_left(pks, maxgap=500) %&gt;% group_by(gtissue, ptissue, gene_id) %&gt;% # need per gene stats summarize(num_overlaps = n(), signal = mean(signal)) %&gt;% as_tibble() %&gt;% # DataFrame to tibble for further processing group_by(gtissue, ptissue) %&gt;% summarize(sum_any_overlaps = sum(num_overlaps &gt; 0), mean_signal=mean(signal)) ## `summarise()` has grouped output by &#39;gtissue&#39;. You can override using the `.groups` argument. ## # A tibble: 6 × 4 ## # Groups: gtissue [2] ## gtissue ptissue sum_any_overlaps mean_signal ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 bladder bladder 2163 1.18 ## 2 bladder kidney 1568 0.929 ## 3 bladder &lt;NA&gt; 859 NA ## 4 kidney bladder 103 0.991 ## 5 kidney kidney 208 0.714 ## 6 kidney &lt;NA&gt; 242 NA What’s wrong with this analysis? We didn’t figure out the expressed promoter, we just looked at the left or rightmost isoform (for + or - strand genes, respectively). References "],["bootstrap-overlap.html", "Chapter 4 Bootstrap overlap", " Chapter 4 Bootstrap overlap Objective: determine if one set of peaks are overlapping another set of peaks more or less than expected when comparing to sets of null features. The null features can be generated in a variety of ways – here we will generate them by resampling large blocks of one of the peak sets. The motivation for sampling blocks, instead of placing features uniformly along the chromosome (“shuffling”), is to better preserve inter-feature distances, because genomic features tend to cluster in the genome, even after considering things like excluded regions. This technique of generating null feature sets is called block bootstrap resampling, and we will use the nullranges implementation of the block bootstrapping algorithm (Mu et al. 2023) to generate the null features, followed by overlap analysis with plyranges (Lee, Cook, and Lawrence 2019). The approach used in nullranges to generate bootstrap ranges closely follows the GSC method proposed by Bickel et al. (2010). Note that an alternative approach for null hypothesis comparisons is to define a set of covariate-matched ranges, an approach also implemented in the nullranges package and described in Davis et al. (2023). For examples of using matching with ranges, see the related articles here. We start by loading the ENCODE kidney and bladder H3K27ac ChIP-seq peaks used in the previous analysis (Dunham and others 2012). library(AnnotationHub) ah &lt;- AnnotationHub() kidney_pks &lt;- ah[[&quot;AH43443&quot;]] bladder_pks &lt;- ah[[&quot;AH44180&quot;]] We will additionally obtain an excluded region set, so that we avoid placing bootstrap features into regions of the genome that don’t typically have features. A variety of possible exclude lists are provided by the excluderanges packages and available via AnnotationHub. Here we will use the hg19.Crawford.wgEncodeDukeMapabilityRegionsExcludable regions, as they are available for hg19, which is the genome used with the peak sets. # query(ah, c(&quot;excluderanges&quot;,&quot;hg19&quot;)) exclude &lt;- ah[[&quot;AH95912&quot;]] save(&quot;data/exclude.rda&quot;) To make the code more generic, we will rename the kidney peaks to x and the bladder peaks to y. We will be looking for overlaps with features in x as the query set: how many of the features in x overlap features in y? The following code reduces our analysis to looking only at standard chromosomes, excluding the mitochondrial genome (too small for including in the block bootstrap). library(GenomeInfoDb) x &lt;- kidney_pks y &lt;- bladder_pks x &lt;- keepStandardChromosomes(x) seqlevels(x, pruning.mode=&quot;coarse&quot;) &lt;- setdiff(seqlevels(x), &quot;chrM&quot;) seqlevels(y, pruning.mode=&quot;coarse&quot;) &lt;- seqlevels(x) seqlevels(exclude, pruning.mode=&quot;coarse&quot;) &lt;- seqlevels(x) We are mostly concerned with avoiding placing bootstrapped features in large regions in the exclude list, so we subset the exclude list to features larger than 500 bp. Why do we have plyranges:: in front of filter? This is because there is a function in the ensembldb package that is also called filter, so it’s a bit safer if we are using both packages to use the package name. library(plyranges) exclude &lt;- exclude %&gt;% plyranges::filter(width(exclude) &gt;= 500) We also subset to the peaks for kidney and bladder which have q-value less than 0.001 and signal value greater than 9 (these are arbitrary filter values, just for demonstration). For further analysis, we will need the features in y to be sorted, for the bootstrapping, here we sort both sets. q_thr &lt;- 3 s_thr &lt;- 9 x &lt;- x %&gt;% plyranges::filter(qValue &gt; q_thr &amp; signalValue &gt; s_thr) %&gt;% sort() y &lt;- y %&gt;% plyranges::filter(qValue &gt; q_thr &amp; signalValue &gt; s_thr) %&gt;% sort() Now we can assess how many overlaps we observed between x and y: obs &lt;- x %&gt;% mutate(n_overlaps = count_overlaps(., y)) obs %&gt;% summarize(total = sum(n_overlaps)) ## DataFrame with 1 row and 1 column ## total ## &lt;integer&gt; ## 1 5073 table( obs$n_overlaps ) ## ## 0 1 2 3 4 6 ## 9453 3966 486 39 3 1 We can check if any of the features of y fall in the excluded regions: y %&gt;% mutate(n_overlaps = count_overlaps(., exclude)) %&gt;% summarize(total = sum(n_overlaps)) ## DataFrame with 1 row and 1 column ## total ## &lt;integer&gt; ## 1 0 The following chunk of code does the bootstrapping of features in y. Here we subset first to metadata columns of interest (an id variable that we create, and the signal value which we rename to signal). pks_to_boot &lt;- y %&gt;% mutate(id = seq_along(.)) %&gt;% plyranges::select(id, signal = signalValue) The bootRanges function returns the bootstrap feature sets combined into one GRanges object – this tidy format facilitates downstream analysis as we will see. The bootstrap iteration is stored in the iter metadata column. library(nullranges) R &lt;- 30 # number of iterations set.seed(5) # set seed for reproducibility boots &lt;- bootRanges(pks_to_boot, blockLength=5e5, R=R, exclude=exclude) boots ## BootRanges object with 174764 ranges and 3 metadata columns: ## seqnames ranges strand | id signal iter ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; &lt;Rle&gt; ## [1] chr1 2011397-2011809 * | 931 14.42934 1 ## [2] chr1 2011973-2012399 * | 932 17.57052 1 ## [3] chr1 2012505-2013073 * | 933 9.64691 1 ## [4] chr1 2503670-2505748 * | 3752 20.84181 1 ## [5] chr1 2505855-2507134 * | 3753 15.29241 1 ## ... ... ... ... . ... ... ... ## [174760] chrY 57499850-57501632 * | 5141 10.09210 30 ## [174761] chrY 57937341-57937960 * | 1062 15.98656 30 ## [174762] chrY 58145916-58146540 * | 264 15.23097 30 ## [174763] chrY 58146662-58147585 * | 265 12.26661 30 ## [174764] chrY 58214091-58214746 * | 266 9.69322 30 ## ------- ## seqinfo: 24 sequences from hg19 genome The default use above of the exclude argument is to drop bootstrapped ranges that overlap the exclude list. We can examine properties of permuted y over iterations, and compare to the original y. To do so, we first add the original features as iter=0. combined &lt;- pks_to_boot %&gt;% mutate(iter=0) %&gt;% bind_ranges(boots) %&gt;% plyranges::select(iter) Then compute summaries: library(tibble) stats &lt;- combined %&gt;% group_by(iter) %&gt;% summarize(n = n(), sum_width=sum(width)/1e6) %&gt;% as_tibble() Original y vs bootstrap: stats[1,] ## # A tibble: 1 × 3 ## iter n sum_width ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 0 5838 5.07 summary(stats[-1,]) ## iter n sum_width ## 1 : 1 Min. :5595 Min. :4.843 ## 2 : 1 1st Qu.:5723 1st Qu.:4.968 ## 3 : 1 Median :5825 Median :5.042 ## 4 : 1 Mean :5825 Mean :5.057 ## 5 : 1 3rd Qu.:5910 3rd Qu.:5.130 ## 6 : 1 Max. :6053 Max. :5.295 ## (Other):24 We can also look at distributions of various aspects, e.g. here the width of features, across a few of the bootstraps and the original feature set y. library(ggplot2) library(ggridges) combined %&gt;% plyranges::filter(iter %in% 0:5) %&gt;% plyranges::select(iter) %&gt;% as_tibble() %&gt;% mutate(type = ifelse(iter == 0, &quot;original&quot;, &quot;boot&quot;)) %&gt;% ggplot(aes(log10(width), iter, fill=type)) + geom_density_ridges(alpha = 0.75) + geom_text(data=head(stats), aes(x=2.25, y=iter, label=paste0(&quot;n=&quot;,n), fill=NULL), vjust=1.5) To compute overlap with the null features, we need the complete() function from the tidyr package. We saw complete() before – this is used in the case that one of the iterations has no overlaps. In this case, we need to record the 0 value for proper inference and plots downstream. It is rare we would have no overlaps with so many features as we have in x and y but it’s good practice to leave the complete() as part of the workflow so the code works correctly in all cases. The overlap per iteration of the bootstrap is accomplished by a series of plyranges / dplyr commands (we switch to dplyr halfway through, after the as_tibble() call). library(tidyr) null &lt;- x %&gt;% join_overlap_inner(boots) %&gt;% group_by(iter) %&gt;% summarize(n_overlaps = n()) %&gt;% as_tibble() %&gt;% complete(iter, fill=list(n_overlaps = 0)) head(null) ## # A tibble: 6 × 2 ## iter n_overlaps ## &lt;fct&gt; &lt;int&gt; ## 1 1 60 ## 2 2 60 ## 3 3 76 ## 4 4 51 ## 5 5 39 ## 6 6 66 sum( obs$n_overlaps ) ## [1] 5073 The observed number of overlaps is about two orders of magnitude more than the bootstrapped number, which makes sense as two tissues would be expected to share a number of similar regulatory regions (as marked by H3K27ac) – more so than randomly placed genomic features, even after accounting for excluded regions and feature clustering. ggplot(null, aes(n_overlaps)) + geom_histogram(binwidth=5) + ggtitle(&quot;bootstrap overlaps&quot;) What could be improved with this analysis? Note that in the above chunks where we count overlaps, we are doubly (or triply, etc.) counting features in x if they hit more than one feature in y or boots. We can count statistics per x feature by adding another group_by into the stream of operations. This also allows us to do more complex operations, such as computing the maximum signal value for the overlapping features in y per feature in x: First add an ID variable to keep track of x features: x &lt;- x %&gt;% mutate(x_id = seq_along(x)) Then perform an inner join, and group by the new x ID: obs &lt;- x %&gt;% join_overlap_inner(pks_to_boot) %&gt;% group_by(x_id) %&gt;% summarize(num_overlaps = n(), max_signal = max(signal)) sum( obs$num_overlaps &gt; 0 ) ## [1] 4495 summary( obs$max_signal ) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 9.002 10.281 12.025 13.029 14.725 35.211 For the bootstrap ranges overlap step, we also need to add iter to the initial group_by, so we count per x feature and per iteration of the bootstrap: null &lt;- x %&gt;% join_overlap_inner(boots) %&gt;% group_by(x_id, iter) %&gt;% summarize(num_overlaps = n()) %&gt;% as_tibble() %&gt;% group_by(iter) %&gt;% summarize(any_hits = sum(num_overlaps &gt; 0)) %&gt;% complete(iter, fill=list(any_hits = 0)) head(null) ## # A tibble: 6 × 2 ## iter any_hits ## &lt;fct&gt; &lt;int&gt; ## 1 1 55 ## 2 2 55 ## 3 3 68 ## 4 4 50 ## 5 5 37 ## 6 6 63 Still, we are seeing much more overlap in the observed data than in the bootstrap data: sum( obs$num_overlaps &gt; 0 ) / mean(null$any_hits) ## [1] 76.75014 The above code chunk then avoids double counting. We could also have made other per-x-feature statistics in the summarize step after the initial group_by, such as maximum signal of overlapping features. What other ways could we have done this analysis? Suppose we don’t just want the count of overlaps, but the rate of overlaps from the y perspective, keeping track of the variable number of features per bootstrap. We demonstrate one approach to obtain this rate for the bootstraps: x_thin &lt;- x %&gt;% plyranges::select(x_id) null &lt;- boots %&gt;% plyranges::select(id, iter) %&gt;% join_overlap_inner(x_thin) %&gt;% group_by(id, iter) %&gt;% summarize(num_overlaps = n()) %&gt;% as_tibble() %&gt;% group_by(iter) %&gt;% summarize(any_hits = sum(num_overlaps &gt; 0)) %&gt;% complete(iter, fill=list(any_hits = 0)) Now combine with the per-iteration total count: totals &lt;- boots %&gt;% group_by(iter) %&gt;% summarize(total=n()) %&gt;% as_tibble() null %&gt;% dplyr::left_join(totals) %&gt;% mutate(rate = any_hits/total) ## Joining with `by = join_by(iter)` ## # A tibble: 30 × 4 ## iter any_hits total rate ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 59 6031 0.00978 ## 2 2 58 5710 0.0102 ## 3 3 73 5758 0.0127 ## 4 4 50 5927 0.00844 ## 5 5 37 5713 0.00648 ## 6 6 59 5888 0.0100 ## 7 7 58 5910 0.00981 ## 8 8 79 5836 0.0135 ## 9 9 59 5770 0.0102 ## 10 10 50 5991 0.00835 ## # ℹ 20 more rows References "],["snp-position-in-peaks.html", "Chapter 5 SNP position in peaks", " Chapter 5 SNP position in peaks Objective: determine the position of a set of SNPs in peaks, that is, determine the relative positions of those SNPs that overlap the peaks. We again will use the ENCODE kidney H3K27ac ChIP-seq peaks used in the previous analysis (Dunham and others 2012). We will create some artificial SNPs: this analysis could generalize to any time that we have two ranges, where we are interested in the relative position of one set of ranges (SNPs) within the other set of ranges (peaks). library(AnnotationHub) ah &lt;- AnnotationHub() kidney_pks &lt;- ah[[&quot;AH43443&quot;]] We will filter the peaks to standard chromosomes, and include the same cutoffs we used in the previous analysis. suppressPackageStartupMessages(library(GenomeInfoDb)) pks &lt;- kidney_pks pks &lt;- keepStandardChromosomes(pks) ## Loading required package: GenomicRanges suppressPackageStartupMessages({ library(dplyr) library(tibble) library(plyranges) }) q_thr &lt;- 3 s_thr &lt;- 9 pks &lt;- pks %&gt;% filter(qValue &gt; q_thr &amp; signalValue &gt; s_thr) %&gt;% sort() A histogram of peak width: library(ggplot2) pks %&gt;% as_tibble %&gt;% filter(width &lt; 5000) %&gt;% ggplot(aes(width)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Let’s subset to peaks that are less than 2000 in width: pks &lt;- pks %&gt;% filter(width &lt; 2000) Now, we may be interested in SNPs that are associated with regulatory function. While we could find these from a database of chromatin QTL or functionally validated variants, here we will just create a simulated set of SNPs for demonstration. set.seed(1) snps &lt;- pks %&gt;% slice(sample.int(n(), 2000)) %&gt;% anchor_5p() %&gt;% mutate(start=start + floor(runif(n(),0,width))) %&gt;% mutate(width=1) snps ## GRanges object with 2000 ranges and 6 metadata columns: ## seqnames ranges strand | name score signalValue pValue qValue ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## [1] chr1 222886667 * | Rank_786 943 28.06788 94.3437 89.9679 ## [2] chr17 1251302 * | Rank_11154 238 10.45065 23.8843 21.0424 ## [3] chr9 75179753 * | Rank_8060 305 12.52016 30.5751 27.5376 ## [4] chrX 70401571 * | Rank_9602 266 11.38197 26.6991 23.7679 ## [5] chr20 37615472 * | Rank_14922 190 9.52741 19.0203 16.3297 ## ... ... ... ... . ... ... ... ... ... ## [1996] chr9 14316343 * | Rank_15136 188 9.11715 18.8452 16.1647 ## [1997] chr18 74800298 * | Rank_15685 181 9.02626 18.1808 15.5192 ## [1998] chr19 52641902 * | Rank_2464 606 19.64891 60.6790 56.9445 ## [1999] chr2 128642862 * | Rank_15514 184 9.18719 18.4512 15.7837 ## [2000] chr6 151005236 * | Rank_13672 203 9.07738 20.3511 17.6170 ## peak ## &lt;numeric&gt; ## [1] 267 ## [2] 458 ## [3] 616 ## [4] 455 ## [5] 414 ## ... ... ## [1996] 461 ## [1997] 173 ## [1998] 1281 ## [1999] 125 ## [2000] 887 ## ------- ## seqinfo: 25 sequences (1 circular) from hg19 genome These should all overlap peaks: snps %&gt;% mutate(n_overlaps = count_overlaps(., pks)) %&gt;% summarize(tab=table(n_overlaps)) ## DataFrame with 1 row and 2 columns ## tab.n_overlaps tab.Freq ## &lt;factor&gt; &lt;integer&gt; ## 1 1 2000 We now have a bit of a hack for this analysis: we add the start position and width of the peak as addition columns of metadata. This is because otherwise, we will lose the start position when we perform the overlap of SNPs in peaks, and we need it for later. pks_trim &lt;- pks %&gt;% select(name) %&gt;% mutate(peak_start=start, peak_width=width) We can then obtain overlaps of SNPs with peaks, and add the relative position of the SNP within the peak extent. We use 1-based indexing, such that if the SNP is the same as the leftmost basepair of the peak, it gets counted as position 1. o &lt;- snps %&gt;% join_overlap_inner(pks_trim) %&gt;% mutate(rel_pos = start - peak_start + 1, rel_frac = (rel_pos - 1) / (peak_width - 1 )) Check our expectations about these new columns: all(o$rel_pos &gt;= 1) ## [1] TRUE all(o$rel_frac &gt;= 0) ## [1] TRUE all(o$rel_frac &lt;= 1) ## [1] TRUE Finally, we can compute a histogram of where the SNPs fall in the peaks: o %&gt;% as_tibble() %&gt;% ggplot(aes(rel_frac)) + geom_histogram(breaks=0:10/10) Now stratifying by width of peak: quantile(o$peak_width, 0:3/3) ## 0% 33.33333% 66.66667% 100% ## 246.0000 813.3333 1289.6667 1998.0000 o %&gt;% mutate(width_bin = cut(peak_width, breaks=c(200,800,1300,2000), include.lowest=TRUE)) %&gt;% as_tibble() %&gt;% ggplot(aes(rel_frac)) + geom_histogram(breaks=0:10/10) + facet_wrap(~width_bin) References "],["gene-plots.html", "Chapter 6 Gene plots", " Chapter 6 Gene plots Objective: for a region of the genome, find peaks near the TSS of genes and then plot their signal strength per gene, stratifying by the tissue origin of the peak. We start by loading the pre-downloaded peaks ranges: load(&quot;data/peaks.rda&quot;) Likewise, we want to use hg19 genes again to match the hg19 peaks: library(TxDb.Hsapiens.UCSC.hg19.knownGene) library(org.Hs.eg.db) g &lt;- genes(TxDb.Hsapiens.UCSC.hg19.knownGene) Adding gene symbols: library(plyranges) g &lt;- g %&gt;% mutate(gene_name = mapIds(org.Hs.eg.db, gene_id, &quot;SYMBOL&quot;, &quot;ENTREZID&quot;)) Find a region of the genome near a kidney-specific gene: g %&gt;% filter(gene_name == &quot;UMOD&quot;) ## GRanges object with 1 range and 2 metadata columns: ## seqnames ranges strand | gene_id gene_name ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; ## 7369 chr16 20344373-20364037 - | 7369 UMOD ## ------- ## seqinfo: 93 sequences (1 circular) from hg19 genome region &lt;- data.frame( seqnames=&quot;chr16&quot;, start=20e6, end=21e6) %&gt;% as_granges() Combine the bladder and kidney peaks, and select certain columns: pks &lt;- bind_ranges(bladder=bladder_pks, kidney=kidney_pks, .id=&quot;tissue&quot;) %&gt;% select(signal=signalValue, tissue) Finally, we perform the overlap join, locating peaks within 100kb of the TSS of the gene. g_with_pks &lt;- g %&gt;% anchor_5p() %&gt;% mutate(width=1) %&gt;% filter_by_overlaps(region) %&gt;% join_overlap_inner(pks, maxgap=1e5) g_with_pks$tissue %&gt;% table() ## . ## bladder kidney ## 208 337 We can construct a faceted set of boxplots, first we make a tibble of data for our plot. library(dplyr) library(tibble) dat &lt;- g_with_pks %&gt;% select(gene_name, signal, tissue, .drop_ranges=TRUE) %&gt;% as_tibble() Then pass the data to ggplot (we could have just passed the data directly, but we plan to re-use the data). library(ggplot2) dat %&gt;% ggplot(aes(tissue, signal)) + geom_boxplot() + facet_wrap(~gene_name) Now let’s try to plot these in context, using plotgardener (Kramer et al. 2022). First we filter down to the peaks near UMOD. umod &lt;- g %&gt;% filter(gene_name == &quot;UMOD&quot;) %&gt;% anchor_5p() %&gt;% mutate(width=1) pks_to_plot &lt;- pks %&gt;% filter_by_overlaps(umod, maxgap=1e5) %&gt;% anchor_center() %&gt;% mutate(width=1e4) # to make the ranges more visible We then define a color scheme for the tissue variable, and make a ggplot object which will be added to our genome plots. cols &lt;- function(n) palette.colors(n+2)[-c(1,3)] col_vec &lt;- cols(2) names(col_vec) &lt;- unique(dat$tissue) p &lt;- dat %&gt;% filter(gene_name == &quot;UMOD&quot;) %&gt;% ggplot(aes(tissue, signal, col=tissue)) + # here we set a seed for jitter geom_point(size=.5, position=position_jitter(width=.1, seed=5)) + scale_color_manual(values = col_vec) We then create some parameters that will be shared across a number of the plots in plotgardener. library(plotgardener) par &lt;- pgParams( chrom = &quot;chr16&quot;, chromstart = round((start(umod) - 1e5)/1e5)*1e5, chromend = round((start(umod) + 4e5)/1e5)*1e5, assembly = &quot;hg19&quot;, just = c(&quot;left&quot;, &quot;bottom&quot;) ) Finally we put all the pieces together on a page (for laying out the plot, first use showGuides=TRUE). pageCreate(width = 5, height = 3, showGuides = FALSE) plotGenes( params = par, x = 0.5, y = 2.5, width = 4, height = .75 ) plotRanges( pks_to_plot, fill = colorby(&quot;tissue&quot;, palette=cols), params = par, x = 0.5, y = 1.75, width = 4, height = 1.75 ) plotGenomeLabel( params = par, x = 0.5, y = 2.5, length = 4, just = c(&quot;left&quot;, &quot;top&quot;) ) plotGG( p + ggtitle(&quot;UMOD&quot;), params = par, x = 2.25, y = 1.75, width = 2.5, height = 1.75 ) References "],["rna-seq-eda.html", "Chapter 7 RNA-seq EDA", " Chapter 7 RNA-seq EDA Objective: learn how to make basic EDA plots (plotting scaled counts) of RNA-seq data using tidy-style verbs. The tidybulk Bioconductor package and associated tidy transcriptomics ecosystem (tidySummarizedExperiment, tidySingleCell, tidyseurat, etc.) provide a bridge between the SummarizedExperiment-style representation of matrix data with attached metadata, to the tidy-style representation of data (one row per observation). For more details on the package, check out the tidybulk website, and the publication: Mangiola et al. (2021). Here we will briefly examine the difference between tidy manipulation of these matrix-style objects compared to how these objects would be manipulated in other Bioconductor workflows (e.g. DESeq2, edgeR, or limma workflows). As you will see, there are multiple ways to generate the same or similar exploratory plots and analyses. we recommend to consider which is more appropriate to your purpose. For package code, you may prefer to have fewer dependencies, going with core Bioconductor objects and packages. For scripting, the “fluent” and piped style of tidybulk may be preferable, and easier for others to read and modify your code at a future date. Here we just compare code for some basic tasks, scaling counts and performing DE with DESeq2. However, note that tidybulk has many functionalities implemented, including dimension reduction and visualization (PCA, MDS, tSNE, UMAP), clustering, gene set testing, cell type composition analysis and cell abundance testing, unwanted variation modeling, imputation, etc. Start by loading this RNA-seq dataset from the following paper: King and Klose (2017) “The pioneer factor OCT4 requires the chromatin remodeller BRG1 to support gene regulatory element function in mouse embryonic stem cells” https://doi.org/10.7554/eLife.22631. The experiment focused on OCT4 as it is a “core pluripotency transcription factor” which “occupies sites that would otherwise be inaccessible and is required to shape the occupancy of additional pluripotency transcription factors.” In this experiment, transcription in mouse embryonic stem cells (ESC) was compared with and without OCT4. This was done using a conditional mouse ESC line where treatment with a compound leads to loss of OCT4 expression. The experiment also involved the same approach to another transcription factor BRG1, but we focus here on the OCT4 samples. First we load the metadata about the samples: library(oct4) dir &lt;- system.file(&quot;extdata&quot;, package=&quot;oct4&quot;) coldata &lt;- read.csv(file.path(dir,&quot;coldata.csv&quot;)) coldata ## names line condition ## 1 SRX2236945 OCT4 untrt ## 2 SRX2236946 OCT4 untrt ## 3 SRX2236947 OCT4 untrt ## 4 SRX2236948 OCT4 trt ## 5 SRX2236949 OCT4 trt ## 6 SRX2236950 OCT4 trt ## 7 SRX2236951 BRG1 untrt ## 8 SRX2236952 BRG1 untrt ## 9 SRX2236953 BRG1 untrt ## 10 SRX2236954 BRG1 trt ## 11 SRX2236955 BRG1 trt ## 12 SRX2236956 BRG1 trt coldata$files &lt;- file.path(dir, &quot;quants&quot;, coldata$names, &quot;quant.sf.gz&quot;) Read in the count data with tximeta, which automatically imports the information about the gene provenance (which transcripts were used to quantify the gene and isoform abundance). We then summarize the quantification to the gene-level, and add the gene SYMBOL. library(tximeta) se &lt;- tximeta(coldata) gse &lt;- summarizeToGene(se) library(org.Mm.eg.db) gse &lt;- addIds(gse, &quot;SYMBOL&quot;) For this workflow, we don’t need the inferential replicates (about uncertainty regarding the quantification), so we keep just the counts, abundances (TPM), and gene lengths. We also manipulate the metadata a little bit. library(SummarizedExperiment) assayNames(gse) assays(gse) &lt;- assays(gse)[1:3] gse$rep &lt;- rep(1:3, 4) colnames(gse) &lt;- paste(gse$line,gse$condition,gse$rep,sep=&quot;-&quot;) assay(gse, &quot;counts&quot;) &lt;- round(assay(gse, &quot;counts&quot;)) # for DE consistency # save for easy loading later save(gse, file=&quot;data/oct4_obj.rda&quot;) library(SummarizedExperiment) load(&quot;data/oct4_obj.rda&quot;) The dataset looks like this (remember it has untreated and treated samples for both OCT4 and BRG1). gse ## class: RangedSummarizedExperiment ## dim: 53697 12 ## metadata(6): tximetaInfo quantInfo ... txomeInfo txdbInfo ## assays(3): counts abundance length ## rownames(53697): ENSMUSG00000000001.4 ENSMUSG00000000003.15 ... ENSMUSG00000117654.1 ## ENSMUSG00000117655.1 ## rowData names(3): gene_id tx_ids SYMBOL ## colnames(12): OCT4-untrt-1 OCT4-untrt-2 ... BRG1-trt-2 BRG1-trt-3 ## colData names(4): names line condition rep We will be interested in the gene set from the Gene Ontology project, which describes maintenance of pluripotency. We can extra this from the mouse organism data package with the following three lines of code: library(AnnotationDbi) library(org.Mm.eg.db) ## # pluripotency tab &lt;- AnnotationDbi::select(org.Mm.eg.db, &quot;GO:0019827&quot;, &quot;SYMBOL&quot;, &quot;GO&quot;) ## &#39;select()&#39; returned 1:many mapping between keys and columns tab &lt;- tab[!duplicated(tab$SYMBOL),] pluri &lt;- tab$SYMBOL Now we start with tidybulk code, comparing in turn to base R. Loading tidySummarizedExperiment allows us to operate on the gse object using familiar “tidy” verbs, thanks to an abstraction described in the tidySummarizedExperiment documentation. We filter the samples that correspond to the OCT4 experiment, and then modify the sample names. Samples are referred to with the special .sample string, while features are referred to with .feature, so here we create a new variable to plot the samples sample_name. library(tidySummarizedExperiment) library(dplyr) library(stringr) oct4 &lt;- gse %&gt;% filter(line == &quot;OCT4&quot;) %&gt;% mutate(sample_name = .sample %&gt;% str_remove(&quot;OCT4-&quot;) %&gt;% factor(levels = unique(.)), condition = condition %&gt;% factor(c(&quot;untrt&quot;,&quot;trt&quot;))) Note, the third line in the mutate call uses the unique function to set the levels: the consequence of this is that the sample_name factor will have levels in the order in which they are present in the current character vector and not alphabetical. oct4 ## # A SummarizedExperiment-tibble abstraction: 322,182 × 18 ## # [90mFeatures=53697 | Samples=6 | Assays=counts, abundance, length[0m ## .feature .sample counts abundance length names line condition rep sample_name gene_id tx_ids ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;chr&gt; &lt;name&gt; ## 1 ENSMUSG00… OCT4-u… 2920 16.6 2953. SRX2… OCT4 untrt 1 untrt-1 ENSMUS… &lt;chr&gt; ## 2 ENSMUSG00… OCT4-u… 0 0 589. SRX2… OCT4 untrt 1 untrt-1 ENSMUS… &lt;chr&gt; ## 3 ENSMUSG00… OCT4-u… 1906 19.0 1688. SRX2… OCT4 untrt 1 untrt-1 ENSMUS… &lt;chr&gt; ## 4 ENSMUSG00… OCT4-u… 9044 74.8 2034. SRX2… OCT4 untrt 1 untrt-1 ENSMUS… &lt;chr&gt; ## 5 ENSMUSG00… OCT4-u… 132 0.826 2688. SRX2… OCT4 untrt 1 untrt-1 ENSMUS… &lt;chr&gt; ## 6 ENSMUSG00… OCT4-u… 0 0 943. SRX2… OCT4 untrt 1 untrt-1 ENSMUS… &lt;chr&gt; ## 7 ENSMUSG00… OCT4-u… 444 1.84 4062. SRX2… OCT4 untrt 1 untrt-1 ENSMUS… &lt;chr&gt; ## 8 ENSMUSG00… OCT4-u… 8 0.0554 2430. SRX2… OCT4 untrt 1 untrt-1 ENSMUS… &lt;chr&gt; ## 9 ENSMUSG00… OCT4-u… 2503 16.3 2588. SRX2… OCT4 untrt 1 untrt-1 ENSMUS… &lt;chr&gt; ## 10 ENSMUSG00… OCT4-u… 610 7.58 1354. SRX2… OCT4 untrt 1 untrt-1 ENSMUS… &lt;chr&gt; ## # ℹ 40 more rows ## # ℹ 6 more variables: SYMBOL &lt;chr&gt;, seqnames &lt;fct&gt;, start &lt;int&gt;, end &lt;int&gt;, width &lt;int&gt;, ## # strand &lt;fct&gt; tidybulk provides access to many steps in bulk analysis, including filtering and count scaling. For details on what is happening behind the scene, see the help, e.g. ?keep_abundant describes that it makes use of edgeR::filterByExpr. library(tidybulk) oct4 &lt;- oct4 %&gt;% keep_abundant(factor_of_interest = condition) %&gt;% scale_abundance(method=&quot;RLE&quot;) # DESeq2 scaling It is straightforward to pipe the data directly into plots: library(ggplot2) oct4 %&gt;% ggplot(aes(sample_name, counts_scaled + 1)) + geom_boxplot() + scale_y_log10() For comparing code, let’s pull out the genes that remain: gene_idx &lt;- oct4 %&gt;% pivot_transcript() %&gt;% pull(.feature) head(gene_idx) ## [1] &quot;ENSMUSG00000000001.4&quot; &quot;ENSMUSG00000000028.15&quot; &quot;ENSMUSG00000000031.16&quot; &quot;ENSMUSG00000000037.16&quot; ## [5] &quot;ENSMUSG00000000056.7&quot; &quot;ENSMUSG00000000058.6&quot; The equivalent code in DESeq2. Understanding this code requires knowledge that boxplot plots columns of a matrix. library(DESeq2) gse_sub &lt;- gse[ gene_idx , gse$line == &quot;OCT4&quot; ] gse_sub$condition &lt;- factor(gse_sub$condition) dds &lt;- gse_sub %&gt;% DESeqDataSet(~condition) %&gt;% estimateSizeFactors() ## using counts and average transcript lengths from tximeta ## using &#39;avgTxLength&#39; from assays(dds), correcting for library size boxplot(counts(dds, normalized=TRUE) + 1, log=&quot;y&quot;) We can also make more interesting plots. E.g. for the genes involved in pluripotency, make a line plot, highlighting OCT4. In addition, center the log counts for each gene (subtract the mean of log counts across samples). oct4 %&gt;% filter(SYMBOL %in% pluri) %&gt;% mutate(logcounts = log10(counts_scaled + 1)) %&gt;% mutate(Oct4 = ifelse(SYMBOL == &quot;Pou5f1&quot;, &quot;red&quot;, &quot;black&quot;)) %&gt;% group_by(.feature) %&gt;% mutate(logcounts = logcounts - mean(logcounts)) %&gt;% ungroup() %&gt;% ggplot(aes(sample_name, logcounts, group=.feature, color=Oct4)) + geom_point() + geom_line() + scale_color_identity() ## tidySummarizedExperiment says: A data frame is returned for independent data analysis. The equivalent code for base R requires defining more intermediate variables and control flow code (the for loop). While there’s nothing particularly right or wrong about the two choices, the above prioritizes the operations in a way that is human readable. In some cases, e.g. performing linear algebra operations on matrices, base R code may prove to be more efficient, which is a consideration for what to use in package source code. pluri_idx &lt;- mcols(dds)$SYMBOL %in% pluri mat &lt;- log10(counts(dds, normalized=TRUE)[pluri_idx,] + 1) mat &lt;- mat - rowMeans(mat) hilite &lt;- rownames(dds)[which(mcols(dds)$SYMBOL == &quot;Pou5f1&quot;)] plot(mat[1,], type=&quot;n&quot;, ylim=c(-1,1), xlab=&quot;samples&quot;, ylab=&quot;logcounts&quot;) for (i in 1:nrow(mat)) { col &lt;- ifelse(rownames(mat)[i] == hilite, &quot;red&quot;, &quot;black&quot;) points(mat[i,], type=&quot;b&quot;, col=col) } We can test for differential expression with DESeq2: res &lt;- dds[gene_idx,] %&gt;% DESeq(quiet=TRUE) %&gt;% results() Or equivalently with tidybulk: oct4 &lt;- oct4 %&gt;% test_differential_abundance(~condition, method=&quot;deseq2&quot;) ## ===================================== ## tidybulk says: All testing methods use raw counts, irrespective of if scale_abundance ## or adjust_abundance have been calculated. Therefore, it is essential to add covariates ## such as batch effects (if applicable) in the formula. ## ===================================== ## using counts and average transcript lengths from tximeta ## ## estimating size factors ## ## using &#39;avgTxLength&#39; from assays(dds), correcting for library size ## ## estimating dispersions ## ## gene-wise dispersion estimates ## ## mean-dispersion relationship ## ## final dispersion estimates ## ## fitting model and testing ## ## tidybulk says: to access the raw results (fitted GLM) do `attr(..., &quot;internals&quot;)$deseq2` ## This message is displayed once per session. tidy_res &lt;- oct4 %&gt;% pivot_transcript() Because we have filtered the two objects identically, we obtain the same test results: all.equal(rownames(res), tidy_res$.feature) ## [1] TRUE table(base_sig = res$padj &lt; .1, tidy_sig = tidy_res$padj &lt; .1) ## tidy_sig ## base_sig FALSE TRUE ## FALSE 17965 0 ## TRUE 0 3512 Finally, we build up to a more interesting plot. Suppose we now want to split the genes involved in pluripotency by the DE result (the significance and LFC), and then add the gene symbol to the side. We begin by building the dataset: plot_data &lt;- oct4 %&gt;% filter(SYMBOL %in% pluri) %&gt;% mutate(logcounts = log10(counts_scaled + 1)) %&gt;% mutate(Oct4 = ifelse(SYMBOL == &quot;Pou5f1&quot;, &quot;red&quot;, &quot;black&quot;)) %&gt;% group_by(.feature) %&gt;% mutate(logcounts = logcounts - mean(logcounts)) %&gt;% ungroup() %&gt;% mutate(gene_type = case_when( padj &lt; .1 &amp; log2FoldChange &gt; 0 ~ &quot;up&quot;, padj &lt; .1 &amp; log2FoldChange &lt; 0 ~ &quot;down&quot;, TRUE ~ &quot;null&quot;)) ## tidySummarizedExperiment says: A data frame is returned for independent data analysis. Now we repeat the code from before, but now faceting by gene_type. Furthermore, we use geom_text_repel to add labels to the right side. library(ggrepel) plot_data %&gt;% filter(gene_type != &quot;null&quot;) %&gt;% ggplot(aes(sample_name, logcounts, group=.feature, color=Oct4)) + geom_point() + geom_line() + geom_text_repel(data=plot_data %&gt;% filter(sample_name == &quot;trt-3&quot;, gene_type != &quot;null&quot;), aes(sample_name, logcounts, label=SYMBOL), nudge_x=.5, seed=1, max.overlaps=Inf) + scale_color_identity() + facet_wrap(~gene_type) + scale_x_discrete(expand = expansion(add = 2)) + xlab(&quot;sample&quot;) References "],["many-genomic-models.html", "Chapter 8 Many genomic models", " Chapter 8 Many genomic models Objective: learn how to run many models (think many linear regressions or many machine learning models) in a tidy framework, by “nesting” the genomic dataset and storing the fitted models as rows of a new column in the nested table. In the previous chapter, we looked at some basic filtering and plotting operations, with perhaps the most interesting operation being a grouped centering of the gene expression. Here we will explore a special case of tidy-style operations on a genomic dataset, in particular a SummarizedExperiment, where we want to run multiple, similar models across groups of features (or likewise, the same could be done to rows). For some other references to these types of operations, you can check out: The “many models” chapter of R for Data Science by Wickham and Grolemund (2017), which introduced the basics of how to run many models in a tidy framework The nest documentation in tidyr The tidymodels package Given the size of genomic data, and the way in which tidySummarizedExperiment abstracts the link between data (assay) and metadata (rowData and colData), we will consider in this chapter how the speed of the operations may be impacted by our choices in setting up the code. In the end, you may find that a more standard way of running the analyses (e.g. using base R/Bioc) is more efficient, depending on the cost incurred by the nesting operation, which we will describe shortly. We will work with a Bioconductor experiment package fission which contains a dataset created by Leong et al. (2014) PMC4050258: Here we integrate high-throughput RNA sequencing and label-free quantitative protein mass spectrometry to investigate global changes in transcript and protein levels in the fission yeast stress response. The experiment considers fission yeast of two strains, wild-type (WT) and atf21\\(\\Delta\\), but here we will not focus on these two strains but just lump the data together, to increase our sample size for the point of building the models. library(fission) data(fission) se &lt;- fission colData(se) ## DataFrame with 36 rows and 4 columns ## strain minute replicate id ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;character&gt; ## GSM1368273 wt 0 r1 wt_0_r1 ## GSM1368274 wt 0 r2 wt_0_r2 ## GSM1368275 wt 0 r3 wt_0_r3 ## GSM1368276 wt 15 r1 wt_15_r1 ## GSM1368277 wt 15 r2 wt_15_r2 ## ... ... ... ... ... ## GSM1368304 mut 120 r2 mut_120_r2 ## GSM1368305 mut 120 r3 mut_120_r3 ## GSM1368306 mut 180 r1 mut_180_r1 ## GSM1368307 mut 180 r2 mut_180_r2 ## GSM1368308 mut 180 r3 mut_180_r3 We again use tidybulk to filter to abundant genes and scale counts for library size: library(tidybulk) se &lt;- se %&gt;% keep_abundant(factor_of_interest = strain) %&gt;% scale_abundance() assayNames(se) ## [1] &quot;counts&quot; &quot;counts_scaled&quot; We make a PCA plot of the log scaled counts, to get a sense for how the samples vary. Note that minute 0 and 180 are similar, as the cells have not yet responded to the stimulus at minute 0. We will later remove these samples for simple modeling. pca &lt;- se %&gt;% reduce_dimensions(method=&quot;PCA&quot;) ## Getting the 500 most variable genes ## Fraction of variance explained by the selected principal components ## # A tibble: 2 × 2 ## `Fraction of variance` PC ## &lt;dbl&gt; &lt;int&gt; ## 1 0.293 1 ## 2 0.182 2 ## tidybulk says: to access the raw results do `attr(..., &quot;internals&quot;)$PCA` library(ggplot2) pca %&gt;% pivot_sample() %&gt;% ggplot(aes(PC1, PC2, shape=strain, color=minute)) + geom_point() We can plot the gene with the most contribution to PC1. Here we will begin working with the data as a tidySE (shortened name for tidySummarizedExperiment): max_pc1 &lt;- which.max(abs(attr(pca, &quot;internals&quot;)[[&quot;PCA&quot;]][[&quot;rotation&quot;]][,&quot;PC1&quot;])) max_pc1 ## SPBC839.06 ## 8 library(tidySummarizedExperiment) se %&gt;% filter(.feature == names(max_pc1)) %&gt;% ggplot(aes(minute, counts_scaled + 1, color=strain, group=strain)) + geom_point() + stat_smooth(se=FALSE) + scale_y_log10() + ggtitle( rowData(se)[names(max_pc1),&quot;symbol&quot;] ) Now, let’s consider a hypothetical analysis question: can we predict the minute (quantitatively) using the log gene expression of a genes in a neighborhood on the chromosome. While this is mostly a contrived question, for the purposes of demonstrating nesting of genomic datasets, you could imagine that there might be modules of responsive genes positioned along the chromosome, and that a prediction task is one way to identify genes that are related to an aspect of the experimental design. The steps will be: Create centered log scaled counts Create “blocks” of genes, by tiling the genome and labeling the genes that fall within the same tile “Nest” the tidySE such that we can operate on the blocks of genes together Run a series of models, each time predicting the minute variable using the expression of the genes in the block Evaluate these models (here simply looking at in-sample training error) “Nesting” a dataset is an operation, similar to group_by, where a variable is used to perform grouped operations. We will specify to nest all the data (columns) besides the grouping variable, such that we end up with a tibble that looks like: grouping variable data value1 RngdSmmE value2 RngdSmmE … … Hence, for every row of the SummarizedExperiment that has value1 for the grouping variable, we will have a subsetted SummarizedExperiment (“ranged” refers to the face that it is rowRanges). Let’s start with the first task. We compute logcounts and then center and scale these values. Likewise, we turn the minute variable from a factor into a numeric, and scale from 0 to 1. These changes would help us compare coefficients across gene later. se &lt;- se %&gt;% mutate(logcounts = log2(counts_scaled + 1), logcounts = (logcounts - mean(logcounts))/sd(logcounts)) se &lt;- se %&gt;% mutate(time = as.numeric(as.character(minute)) / 180) se ## # A SummarizedExperiment-tibble abstraction: 210,996 × 20 ## # [90mFeatures=5861 | Samples=36 | Assays=counts, counts_scaled, logcounts[0m ## .feature .sample counts counts_scaled logcounts strain minute replicate id TMM multiplier ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 SPAC212.09c GSM136… 23 23.1 -1.70 wt 0 r1 wt_0… 1.18 1.00 ## 2 SPAC212.04c GSM136… 37 37.1 -1.42 wt 0 r1 wt_0… 1.18 1.00 ## 3 SPAC977.11 GSM136… 155 155. -0.581 wt 0 r1 wt_0… 1.18 1.00 ## 4 SPAC977.13c GSM136… 19 19.0 -1.81 wt 0 r1 wt_0… 1.18 1.00 ## 5 SPAC977.15 GSM136… 91 91.2 -0.896 wt 0 r1 wt_0… 1.18 1.00 ## 6 SPAC977.16c GSM136… 184 184. -0.479 wt 0 r1 wt_0… 1.18 1.00 ## 7 SPNCRNA.607 GSM136… 49 49.1 -1.26 wt 0 r1 wt_0… 1.18 1.00 ## 8 SPAC1F8.06 GSM136… 105 105. -0.812 wt 0 r1 wt_0… 1.18 1.00 ## 9 SPAC1F8.08 GSM136… 151 151. -0.597 wt 0 r1 wt_0… 1.18 1.00 ## 10 SPAC11D3.19 GSM136… 22 22.1 -1.72 wt 0 r1 wt_0… 1.18 1.00 ## # ℹ 40 more rows ## # ℹ 9 more variables: time &lt;dbl&gt;, symbol &lt;chr&gt;, biotype &lt;fct&gt;, .abundant &lt;lgl&gt;, seqnames &lt;fct&gt;, ## # start &lt;int&gt;, end &lt;int&gt;, width &lt;int&gt;, strand &lt;fct&gt; For demonstration, we will work with just the first chromosome: I. For our task of modeling the design using gene expression, in blocks along the genome, we need to create tiles to determine which genes to group together. To do so, we need to know how long the chromosomes are. The original publication states: Sequencing reads were aligned to the fission yeast genome (PomBase database release 11) Usually we would look for the length of chromosomes from a source that hosts the reference (e.g. UCSC genome lengths can be obtained using Seqinfo). In this case, I wasn’t able to find information about this particular release, so I just guess the length of the chromosome using the gene with the largest coordinate: library(plyranges) rowRanges(se) %&gt;% filter(seqnames == &quot;I&quot;) %&gt;% summarize(max(end)) ## DataFrame with 1 row and 1 column ## max.end. ## &lt;integer&gt; ## 1 5556768 genes_to_keep &lt;- rowRanges(se) %&gt;% filter(seqnames == &quot;I&quot;) %&gt;% names() We now filter the se object to remove the 0 time point, and to keep just the features on chromosome I. se0 &lt;- se # save the original object se &lt;- se %&gt;% filter(time != 0) %&gt;% filter(.feature %in% genes_to_keep) To make tiles on chromosome I, we just need to specify the extent (here I plug in the largest gene coordinate): tiles &lt;- data.frame(seqnames=&quot;I&quot;,start=1,end=5.6e6) %&gt;% as_granges() %&gt;% tile_ranges(width=1e5) %&gt;% select(-partition) %&gt;% mutate(tile = seq_along(.)) tiles ## GRanges object with 56 ranges and 1 metadata column: ## seqnames ranges strand | tile ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; ## [1] I 1-100000 * | 1 ## [2] I 100001-200000 * | 2 ## [3] I 200001-300000 * | 3 ## [4] I 300001-400000 * | 4 ## [5] I 400001-500000 * | 5 ## ... ... ... ... . ... ## [52] I 5100001-5200000 * | 52 ## [53] I 5200001-5300000 * | 53 ## [54] I 5300001-5400000 * | 54 ## [55] I 5400001-5500000 * | 55 ## [56] I 5500001-5600000 * | 56 ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths We now determine which tile the genes fall in (using TSS only, so that genes fall in a single tile). We can add this data back onto the tidySE using a left_join: ranges_tiled &lt;- rowRanges(se) %&gt;% anchor_5p() %&gt;% mutate(width=1) %&gt;% join_overlap_left(tiles) %&gt;% mutate(.feature = names(.)) %&gt;% select(tile, .feature, .drop_ranges=TRUE) %&gt;% as_tibble() nrow(se) == nrow(ranges_tiled) ## [1] TRUE # combining the tile information with the SE se &lt;- se %&gt;% left_join(ranges_tiled) ## Joining with `by = join_by(.feature)` ## Joining with `by = join_by(.feature)` Typically we have a little less than 50 genes per tile: summary(as.vector(table(rowData(se)$tile))) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 5.00 44.00 49.00 46.98 51.25 59.00 Next, we want to create a nested table, where tidySE objects are grouped by tile and placed within a column of the table. There are a few choices on how to proceed. One option would be to pivot_wider the tidySE, as in this chunk below: se %&gt;% filter(.feature %in% rownames(se)[1:5]) %&gt;% select(.sample, strain, time, .feature, logcounts) %&gt;% pivot_wider(names_from = .feature, values_from = logcounts) ## tidySummarizedExperiment says: A data frame is returned for independent data analysis. ## # A tibble: 30 × 8 ## .sample strain time SPAC212.09c SPAC212.04c SPAC977.11 SPAC977.13c SPAC977.15 ## &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GSM1368276 wt 0.0833 -1.30 -1.51 -0.705 -1.85 -0.617 ## 2 GSM1368277 wt 0.0833 -1.03 -2.01 -1.19 -1.27 -0.677 ## 3 GSM1368278 wt 0.0833 -0.993 -2.11 -1.13 -1.88 -0.364 ## 4 GSM1368279 wt 0.167 -0.802 -1.40 -0.690 -0.324 -0.966 ## 5 GSM1368280 wt 0.167 -0.574 -1.06 -0.847 -0.399 -0.835 ## 6 GSM1368281 wt 0.167 -0.685 -0.880 -0.685 -0.571 -0.779 ## 7 GSM1368282 wt 0.333 -0.744 -1.56 -1.10 -1.45 -1.45 ## 8 GSM1368283 wt 0.333 -0.959 -1.58 -0.910 -0.828 -1.11 ## 9 GSM1368284 wt 0.333 -0.832 -1.51 -0.874 -1.07 -1.01 ## 10 GSM1368285 wt 0.667 -1.03 -1.49 -0.866 -1.74 -1.40 ## # ℹ 20 more rows This ends up being a bit slower than just extracting the information with assay and transposing it. First let’s create our nested dataset: library(purrr) nested &lt;- se %&gt;% nest(data = -tile) nested ## # A tibble: 56 × 2 ## tile data ## &lt;int&gt; &lt;list&gt; ## 1 1 &lt;RngdSmmE[,30]&gt; ## 2 2 &lt;RngdSmmE[,30]&gt; ## 3 3 &lt;RngdSmmE[,30]&gt; ## 4 4 &lt;RngdSmmE[,30]&gt; ## 5 5 &lt;RngdSmmE[,30]&gt; ## 6 6 &lt;RngdSmmE[,30]&gt; ## 7 7 &lt;RngdSmmE[,30]&gt; ## 8 8 &lt;RngdSmmE[,30]&gt; ## 9 9 &lt;RngdSmmE[,30]&gt; ## 10 10 &lt;RngdSmmE[,30]&gt; ## # ℹ 46 more rows Now, by row, extract out and transpose log scaled counts: nested &lt;- nested %&gt;% mutate(trainx = map(data, \\(d) { t(assay(d, &quot;logcounts&quot;)) })) nested ## # A tibble: 56 × 3 ## tile data trainx ## &lt;int&gt; &lt;list&gt; &lt;list&gt; ## 1 1 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 20]&gt; ## 2 2 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 54]&gt; ## 3 3 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 41]&gt; ## 4 4 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 54]&gt; ## 5 5 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 44]&gt; ## 6 6 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 53]&gt; ## 7 7 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 45]&gt; ## 8 8 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 47]&gt; ## 9 9 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 41]&gt; ## 10 10 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 59]&gt; ## # ℹ 46 more rows We fit an elastic net model (Friedman, Hastie, and Tibshirani 2010). library(glmnet) y &lt;- colData(se)$time nested &lt;- nested %&gt;% mutate(fit = map(trainx, \\(x) { glmnet(x = x, y = y, alpha = .5, lambda = .1) })) nested ## # A tibble: 56 × 4 ## tile data trainx fit ## &lt;int&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; ## 1 1 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 20]&gt; &lt;elnet&gt; ## 2 2 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 54]&gt; &lt;elnet&gt; ## 3 3 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 41]&gt; &lt;elnet&gt; ## 4 4 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 54]&gt; &lt;elnet&gt; ## 5 5 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 44]&gt; &lt;elnet&gt; ## 6 6 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 53]&gt; &lt;elnet&gt; ## 7 7 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 45]&gt; &lt;elnet&gt; ## 8 8 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 47]&gt; &lt;elnet&gt; ## 9 9 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 41]&gt; &lt;elnet&gt; ## 10 10 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 59]&gt; &lt;elnet&gt; ## # ℹ 46 more rows We use the elastic net model, to predict the design from the gene expression (a variable number and set of genes per tile): nested &lt;- nested %&gt;% mutate( pred = map2(trainx, fit, \\(tr,fit) { predict(fit, newx = tr)[,1] }), n = map_dbl(data, nrow), in_r2 = map_dbl(pred, \\(pred) cor(pred,y)^2) ) nested ## # A tibble: 56 × 7 ## tile data trainx fit pred n in_r2 ## &lt;int&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 20]&gt; &lt;elnet&gt; &lt;dbl [30]&gt; 20 0.851 ## 2 2 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 54]&gt; &lt;elnet&gt; &lt;dbl [30]&gt; 54 0.908 ## 3 3 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 41]&gt; &lt;elnet&gt; &lt;dbl [30]&gt; 41 0.906 ## 4 4 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 54]&gt; &lt;elnet&gt; &lt;dbl [30]&gt; 54 0.880 ## 5 5 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 44]&gt; &lt;elnet&gt; &lt;dbl [30]&gt; 44 0.912 ## 6 6 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 53]&gt; &lt;elnet&gt; &lt;dbl [30]&gt; 53 0.892 ## 7 7 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 45]&gt; &lt;elnet&gt; &lt;dbl [30]&gt; 45 0.894 ## 8 8 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 47]&gt; &lt;elnet&gt; &lt;dbl [30]&gt; 47 0.856 ## 9 9 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 41]&gt; &lt;elnet&gt; &lt;dbl [30]&gt; 41 0.890 ## 10 10 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 × 59]&gt; &lt;elnet&gt; &lt;dbl [30]&gt; 59 0.894 ## # ℹ 46 more rows Finally we plot the prediction \\(R^2\\), and compare to the number of genes in the models: library(ggplot2) ggplot(nested, aes(n, in_r2)) + geom_point() + ylab(&quot;in-sample r2&quot;) Questions: How else could we have performed the analysis, without doing the nesting operation? Would this have been faster? What other variables would need to be created to keep track of the many models? What advantages or disadvantages can you think about for the different ways of running multiple models across large genomic datasets? References "],["isoform-analysis.html", "Chapter 9 Isoform analysis", " Chapter 9 Isoform analysis Objective: compare the structure of isoforms within a gene using grouping and disjoin operations. There are many packages in Bioconductor that allow for isoform-level analysis across samples (also called transcript-level analysis). Packages that facilitate differential transcript analysis include DEXSeq and DRIMSeq (demonstrated in the rnaseqDTU workflow), and newer packages satuRn and fishpond. Once you’ve identified isoforms of interest within a gene, perhaps isoforms that switch in terms of their expression after cells are treated, one can use the IsoformSwitchAnalyzeR Bioconductor package to visualize and analyze a set of isoform switches (Vitting-Seerup and Sandelin 2019). For example, one can test the functional consequences of a set of isoform switches in terms of the gain or loss of protein domains, or splicing-centric changes (e.g. alternative 3’ or 5’ acceptor sites, alternative transcription start or ends sites, etc.) IsoformSwitchAnalyzeR is a multi-feature and mature package for this type of analysis, but we can perform some simpler within-gene isoform comparisons using plyranges, mostly for demonstration. Here we will suppose that we have somehow identified isoforms of interest, and we want to compare these isoforms to other isoforms of the same gene. For simplicity, we will focus on one isoform per gene, for a particular set of interesting genes, just picking isoforms at random for genes on chr1. We could use plyranges to compare various metadata about isoforms or exons e.g. RNA-seq or ChIP-seq coverage, sequence content, etc. But here we will just compare isoforms alone by the interval definitions. Then to reformulate: Specific objective 1: compare one isoform per gene to the others, in terms of the extent from TSS to TES. What makes this isoform distinct? We will start again with the transcript database we’ve used before: library(TxDb.Hsapiens.UCSC.hg19.knownGene) txdb &lt;- TxDb.Hsapiens.UCSC.hg19.knownGene txp &lt;- transcripts(txdb) For further operations it will be convenient to have the tx_id be a character variable, and we filter now to a set of genes of interest (here just picking those on chr1): library(plyranges) txp &lt;- txp %&gt;% mutate(tx_id = as.character(tx_id)) %&gt;% filter(seqnames == &quot;chr1&quot;) It is sometimes useful to have other identifiers, such as the gene ID (Entrez)… txp &lt;- txp %&gt;% mutate(gene_id = mapIds( txdb, keys=tx_id, column=&quot;GENEID&quot;, keytype=&quot;TXID&quot;) ) %&gt;% filter(!is.na(gene_id)) …and the gene symbol. For simplicity we will keep genes that have a non-NA symbol but this step is not necessary. library(org.Hs.eg.db) txp &lt;- txp %&gt;% mutate(symbol = mapIds( org.Hs.eg.db, keys=gene_id, column=&quot;SYMBOL&quot;, keytype=&quot;ENTREZID&quot;) ) %&gt;% filter(!is.na(symbol)) The following is one way to identify which isoforms belong to multi-isoform genes: # this is slow for some reason... ## txp %&gt;% ## group_by(gene_id) %&gt;% ## mutate(ntxp = n()) %&gt;% ## ungroup() # this is faster... txp &lt;- txp %&gt;% mutate(ntxp = as.integer(table(txp$gene_id)[ gene_id ])) We can now filter to the multi-isoform genes: txp &lt;- txp %&gt;% filter(ntxp &gt; 1) Here we arbitrarily pick one isoform per gene, first by identifying those in a tibble… library(tibble) set.seed(3) pick_one &lt;- txp %&gt;% as_tibble() %&gt;% group_by(gene_id) %&gt;% slice(sample.int(n(), size=1)) %&gt;% dplyr::pull(tx_id) …then we can label these in our txp object. We will track these with an integer, 1 for the isoform of interest, and 0 for the others. txp &lt;- txp %&gt;% mutate(the_one = as.integer(tx_id %in% pick_one)) To identify which “parts” of the TSS-to-TES interval belong to which isoform, we can use disjoin_ranges. This breaks up the ranges, here grouped by gene, into distinct parts, and labels those according to whatever metadata variables we specify. Here we specify to combine tx_id into a collapsed string, but we could also perform numeric operations, e.g. min or mean etc. And we can specify more than one new variable to be created during the disjoin_ranges operation. As with reduce_ranges, this operation can be _directed or not. txp %&gt;% group_by(gene_id) %&gt;% disjoin_ranges(tx_ids = paste(tx_id,collapse=&quot;,&quot;)) ## GRanges object with 4438 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id tx_ids ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; ## [1] chr1 11874-14409 * | 100287102 1,2,3 ## [2] chr1 367659-368597 * | 729759 11 ## [3] chr1 621096-622034 * | 729759 4099 ## [4] chr1 762971-763177 * | 643837 14,15,16,17,18 ## [5] chr1 763178-778984 * | 643837 14,15,16,17,18,19 ## ... ... ... ... . ... ... ## [4434] chr1 249144203-249150234 * | 55657 7962,7963,7964,7965,.. ## [4435] chr1 249150235-249152264 * | 55657 7963,7964,7965,7966,.. ## [4436] chr1 249152265-249152912 * | 55657 7964,7965,7966,7967 ## [4437] chr1 249152913-249153125 * | 55657 7965,7966,7967 ## [4438] chr1 249153126-249153315 * | 55657 7966,7967 ## ------- ## seqinfo: 93 sequences (1 circular) from hg19 genome Here we try to answer the specific objective, by labeling which parts belong exclusively to the isoform of interest by computing min(the_one) (try to convince yourself that this does in fact identify these intervals). txp %&gt;% group_by(gene_id) %&gt;% disjoin_ranges(the_one_parts = min(the_one)) %&gt;% filter(the_one_parts &gt; 0) ## GRanges object with 257 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id the_one_parts ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;integer&gt; ## [1] chr1 621096-622034 * | 729759 1 ## [2] chr1 2407754-2411622 * | 9651 1 ## [3] chr1 2495189-2495267 * | 8764 1 ## [4] chr1 3689334-3689351 * | 388588 1 ## [5] chr1 6268367-6268677 * | 388591 1 ## ... ... ... ... . ... ... ## [253] chr1 243651535-243663020 * | 10000 1 ## [254] chr1 244571794-244586136 * | 159 1 ## [255] chr1 246580715-246670644 * | 64754 1 ## [256] chr1 247492918-247495045 * | 84838 1 ## [257] chr1 249119835-249120154 * | 80851 1 ## ------- ## seqinfo: 93 sequences (1 circular) from hg19 genome Do the parts identified make sense if we check one gene? txp %&gt;% filter(gene_id == &quot;9651&quot;) ## GRanges object with 6 ranges and 6 metadata columns: ## seqnames ranges strand | tx_id tx_name gene_id symbol ntxp ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;integer&gt; ## [1] chr1 2407754-2436964 + | 134 uc001aji.1 9651 PLCH2 6 ## [2] chr1 2411623-2436892 + | 135 uc010nyz.2 9651 PLCH2 6 ## [3] chr1 2411623-2436964 + | 136 uc009vle.1 9651 PLCH2 6 ## [4] chr1 2411623-2436965 + | 137 uc001ajj.1 9651 PLCH2 6 ## [5] chr1 2411623-2436969 + | 138 uc001ajk.1 9651 PLCH2 6 ## [6] chr1 2430183-2436964 + | 139 uc001ajl.1 9651 PLCH2 6 ## the_one ## &lt;integer&gt; ## [1] 1 ## [2] 0 ## [3] 0 ## [4] 0 ## [5] 0 ## [6] 0 ## ------- ## seqinfo: 93 sequences (1 circular) from hg19 genome Let’s pause and consider what we’ve answered so far. We asked, for a given isoform per gene, what parts (intervals) uniquely define that isoform, when we just consider TSS-to-TES extent (ignoring the exonic/intronic structure). We started here mostly for simplicity, but typically we care about transcribed sequence, so let’s repeat this task, now considering what exonic parts are unique to one isoform per gene. Specific objective 2: compare one isoform per gene to the others, in terms of the exonic intervals. What makes this isoform distinct? To start, we will need a list of the exons, grouped by transcript. ebt &lt;- exonsBy(txdb, by=&quot;tx&quot;) ebt &lt;- ebt[txp$tx_id] # subset to those txp/genes of interest Here, we could have also used bind_ranges but I find that for very large lists of ranges, unlist is faster: exons &lt;- unlist(ebt) %&gt;% select(exon_id, exon_rank) %&gt;% mutate(tx_id = rep(names(ebt), lengths(ebt))) exons ## GRanges object with 67595 ranges and 3 metadata columns: ## seqnames ranges strand | exon_id exon_rank tx_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 chr1 11874-12227 + | 1 1 1 ## 1 chr1 12613-12721 + | 3 2 1 ## 1 chr1 13221-14409 + | 5 3 1 ## 2 chr1 11874-12227 + | 1 1 2 ## 2 chr1 12595-12721 + | 2 2 2 ## ... ... ... ... . ... ... ... ## 7967 chr1 249149757-249149834 - | 27460 7 7967 ## 7967 chr1 249149579-249149657 - | 27459 8 7967 ## 7967 chr1 249148136-249148250 - | 27458 9 7967 ## 7967 chr1 249144881-249144980 - | 27457 10 7967 ## 7967 chr1 249144203-249144715 - | 27456 11 7967 ## ------- ## seqinfo: 93 sequences (1 circular) from hg19 genome The exons ranges are missing some of our key metadata from txp. We can add this, by first select-ing what we want from txp, turning this into a tibble and left_join-ing to the exons. I add an all.equal step to make sure we have the two tables lined up, before we add the extra columns with cbind. Some of this code wouldn’t be necessary for TranscriptDb with more details exons output, as with ensembldb. txp_data &lt;- txp %&gt;% select(tx_id, gene_id, ntxp, the_one, .drop_ranges=TRUE) %&gt;% as_tibble() ids &lt;- dplyr::left_join(tibble(tx_id = exons$tx_id), txp_data, by=&quot;tx_id&quot;) ids ## # A tibble: 67,595 × 4 ## tx_id gene_id ntxp the_one ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 1 100287102 3 1 ## 2 1 100287102 3 1 ## 3 1 100287102 3 1 ## 4 2 100287102 3 0 ## 5 2 100287102 3 0 ## 6 2 100287102 3 0 ## 7 3 100287102 3 0 ## 8 3 100287102 3 0 ## 9 3 100287102 3 0 ## 10 11 729759 2 0 ## # ℹ 67,585 more rows all.equal(exons$tx_id, ids$tx_id) ## [1] TRUE mcols(exons) &lt;- cbind(mcols(exons), ids %&gt;% select(-tx_id)) exons ## GRanges object with 67595 ranges and 6 metadata columns: ## seqnames ranges strand | exon_id exon_rank tx_id gene_id ntxp ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;character&gt; &lt;integer&gt; ## 1 chr1 11874-12227 + | 1 1 1 100287102 3 ## 1 chr1 12613-12721 + | 3 2 1 100287102 3 ## 1 chr1 13221-14409 + | 5 3 1 100287102 3 ## 2 chr1 11874-12227 + | 1 1 2 100287102 3 ## 2 chr1 12595-12721 + | 2 2 2 100287102 3 ## ... ... ... ... . ... ... ... ... ... ## 7967 chr1 249149757-249149834 - | 27460 7 7967 55657 6 ## 7967 chr1 249149579-249149657 - | 27459 8 7967 55657 6 ## 7967 chr1 249148136-249148250 - | 27458 9 7967 55657 6 ## 7967 chr1 249144881-249144980 - | 27457 10 7967 55657 6 ## 7967 chr1 249144203-249144715 - | 27456 11 7967 55657 6 ## the_one ## &lt;integer&gt; ## 1 1 ## 1 1 ## 1 1 ## 2 0 ## 2 0 ## ... ... ## 7967 0 ## 7967 0 ## 7967 0 ## 7967 0 ## 7967 0 ## ------- ## seqinfo: 93 sequences (1 circular) from hg19 genome We repeat similar code as performed above with txp, now identifying parts of exons that are unique to the isoform of interest, per gene: exon_parts &lt;- exons %&gt;% group_by(gene_id) %&gt;% disjoin_ranges(the_one_parts = min(the_one)) %&gt;% filter(the_one_parts &gt; 0) exon_parts ## GRanges object with 1604 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id the_one_parts ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;integer&gt; ## [1] chr1 621096-622034 * | 729759 1 ## [2] chr1 776580-778984 * | 643837 1 ## [3] chr1 898412-898488 * | 339451 1 ## [4] chr1 898634-898716 * | 339451 1 ## [5] chr1 898885-899229 * | 339451 1 ## ... ... ... ... . ... ... ## [1600] chr1 247301447-247302017 * | 7678 1 ## [1601] chr1 247493268-247493383 * | 84838 1 ## [1602] chr1 247494734-247495045 * | 84838 1 ## [1603] chr1 249120034-249120154 * | 80851 1 ## [1604] chr1 249152521-249152710 * | 55657 1 ## ------- ## seqinfo: 93 sequences (1 circular) from hg19 genome To confirm that we’ve identified the right parts, let’s use plotgardener to visualize a particular gene: txp %&gt;% filter(gene_id == &quot;339451&quot;) ## GRanges object with 5 ranges and 6 metadata columns: ## seqnames ranges strand | tx_id tx_name gene_id symbol ntxp ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;integer&gt; ## [1] chr1 895967-901099 + | 55 uc001aca.2 339451 KLHL17 5 ## [2] chr1 896829-897858 + | 56 uc001acb.1 339451 KLHL17 5 ## [3] chr1 897009-897858 + | 57 uc010nya.1 339451 KLHL17 5 ## [4] chr1 897461-901099 + | 58 uc001acc.2 339451 KLHL17 5 ## [5] chr1 897735-899229 + | 59 uc010nyb.1 339451 KLHL17 5 ## the_one ## &lt;integer&gt; ## [1] 0 ## [2] 0 ## [3] 0 ## [4] 0 ## [5] 1 ## ------- ## seqinfo: 93 sequences (1 circular) from hg19 genome tx_to_show &lt;- txp %&gt;% filter(gene_id == &quot;339451&quot; &amp; the_one == 1) %&gt;% as_tibble() %&gt;% dplyr::pull(tx_name) these_parts &lt;- exon_parts %&gt;% filter(gene_id == &quot;339451&quot;) We lay out a page zooming into this gene and its isoforms: library(plotgardener) par &lt;- pgParams( chrom = &quot;chr1&quot;, chromstart = 895.9e3, chromend = 901.2e3, assembly = &quot;hg19&quot;, just = c(&quot;left&quot;, &quot;bottom&quot;) ) We will highlight our isoform of interest: hilite &lt;- data.frame(transcript=tx_to_show, color=&quot;magenta&quot;) Finally, putting it all together: pageCreate(width = 5, height = 2.5, showGuides = FALSE) plotTranscripts( params = par, x = 0.5, y = 1.5, width = 4, height = 1.5, transcriptHighlights = hilite ) plotRanges( these_parts, fill=&quot;darkorchid&quot;, params = par, x = 0.5, y = 1.75, width = 4, height = .25 ) label &lt;- paste(&quot;unique parts of&quot;, tx_to_show) plotText( label = label, fontcolor = &quot;darkorchid&quot;, params = par, x = 3.1, y = 1.75, just = c(&quot;left&quot;, &quot;bottom&quot;), fontsize = 8 ) plotGenomeLabel( params = par, x = 0.5, y = 2, length = 4, just = c(&quot;left&quot;, &quot;top&quot;) ) Questions: How else could we have found parts of one isoform per gene, that do not belong to any other isoforms of the genes. Would other approaches have any limitations? References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
