[["index.html", "Tidy Ranges Tutorial About", " Tidy Ranges Tutorial nullranges devel team 2023-03-04 About We provide examples of computing operations on genomic ranges using the tidy data philosophy. These examples focus on the packages dplyr, plyranges, nullranges, and excluderanges. "],["join-is-an-overlap.html", "Chapter 1 Join is an overlap", " Chapter 1 Join is an overlap Objective: learn that a “join” is like an overlap. We start with a quick example explaining why we use functions called join. library(dplyr) library(tidyr) library(randomNames) Let’s set up a simulation where we have 17 classmates (not counting ourselves) in a school of 118. Suppose every member of the class has 12 friends outside of class. We want to find out, for each classmate, how many friends we have in common and also, of our shared friends, what is a typical birthday. Let’s define typical as the median birthday of our shared friends. m &lt;- 17 # size of class n &lt;- 100 # size of others in school nf &lt;- 12 # number of friends outside class set.seed(5) people &lt;- randomNames(m + n, name.order=&quot;first.last&quot;, name.sep=&quot; &quot;) We define the population of potential friends (those outside the class) as pop, and our 12 friends are in friends. Finally, we define the people that are in our class as class_people. pop &lt;- data.frame(person=people[-(1:m)], birthday=sample(31, n, TRUE)) friends &lt;- data.frame(friend=sample(people, nf)) class_people &lt;- people[1:m] The following sets up a data.frame, where each row gives, for a given classmate, their friends, and the friends’ birthdays. loop &lt;- rep(1:m, each=nf) idx &lt;- as.vector(replicate(m, sample(n, nf))) class &lt;- data.frame(classmate=class_people[loop], friend=pop$person[idx], birthday=pop$birthday[idx]) Sort this by classmate alphabetically, and make classmate into a factor. This last step is important, as it will help us to keep track of the classmates for whom we share no friends outside of class. class &lt;- class %&gt;% arrange(classmate) %&gt;% mutate(classmate=factor(classmate)) We perform an inner_join by \"friend\". This just means we look for classmates where we have overlapping friends, and we drop the rows where we don’t share any friends. “Inner” refers to the fact that we are keeping the overlap in the inside of two intersecting circles. Note that the join operation brings along the metadata (extra data) about the friends’ birthdays. shared_friends &lt;- friends %&gt;% inner_join(class, by=&quot;friend&quot;) %&gt;% arrange(classmate, friend) %&gt;% relocate(classmate) # classmate to 1st column shared_friends ## classmate friend birthday ## 1 Brandon Jones Christopher Rivera 13 ## 2 Brandon Jones Jose Jimenez 26 ## 3 Brandon Jones Maria Hernandez 15 ## 4 Brandon Jones Tuli Hoang 7 ## 5 Christopher Herron Tuli Hoang 7 ## 6 Christopher Herron William Steinbach 15 ## 7 Haley Polhamus Cellene Millhone 23 ## 8 Haley Polhamus William Steinbach 15 ## 9 Juan Villegas Cabrera Alyssa Kinanee 30 ## 10 Juan Villegas Cabrera Malik Gammon 5 ## 11 Juan Villegas Cabrera Tajhae Bohanna 31 ## 12 Maisara el-Arshad Kaylyn Judkins 2 ## 13 Maisara el-Arshad Maria Hernandez 15 ## 14 Maisara el-Arshad Tajhae Bohanna 31 ## 15 Michael Mcgill Christopher Rivera 13 ## 16 Michael Mcgill Maria Hernandez 15 ## 17 Noah Pettinger Kaylyn Judkins 2 ## 18 Noah Pettinger Tajhae Bohanna 31 ## 19 Orion Villani Malik Gammon 5 ## 20 Shane Ranaldi Alyssa Kinanee 30 ## 21 Shane Ranaldi William Steinbach 15 ## 22 Stephanie Hernandez Asmaa el-Abdelnour 29 ## 23 Zachary Roe-Huffman Maria Hernandez 15 Lastly, we perform some summarization: compute the number of friends in common with n() and the median birthday of shared friends. The complete call at the end fills in 0 for those classmates for whom we share no friends (here, the use of factor earlier becomes relevant). We can choose which columns to fill in, and what value to add. shared_friends %&gt;% group_by(classmate) %&gt;% summarize(in_common=n(), median_bday=median(birthday)) %&gt;% complete(classmate, fill=list(in_common=0,median_bday=-1)) ## # A tibble: 17 × 3 ## classmate in_common median_bday ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Aaliyah Minter 0 -1 ## 2 Brandon Jones 4 14 ## 3 Christopher Herron 2 11 ## 4 Collin Leon 0 -1 ## 5 Haley Polhamus 2 19 ## 6 Juan Villegas Cabrera 3 30 ## 7 Khaalid el-Ammar 0 -1 ## 8 Kianna Mcalevy 0 -1 ## 9 Maazin al-Ismael 0 -1 ## 10 Maisara el-Arshad 3 15 ## 11 Michael Mcgill 2 14 ## 12 Noah Pettinger 2 16.5 ## 13 Orion Villani 1 5 ## 14 Shane Ranaldi 2 22.5 ## 15 Stephanie Hernandez 1 29 ## 16 Xavier Urueta 0 -1 ## 17 Zachary Roe-Huffman 1 15 "],["overlap-granges-with-plyranges.html", "Chapter 2 Overlap GRanges with plyranges", " Chapter 2 Overlap GRanges with plyranges Objective: compute overlaps and summary statistics between two sets of genomic ranges. In particular, suppose we want to compute the mean genomic extent (distance from left-most to right-most basepair) of genes overlapping a set of query ranges. We move on from the “classroom example” by seeing how we compute overlaps when the features are in genomic space. We will use GRanges in the Bioconductor package GenomicRanges to represent the features and plyranges to compute the overlaps, similarly to how we used dplyr to compute the overlaps in the previous analysis. So data.frame is to dplyr as GRanges is to plyranges. library(plyranges) Note the structure of the GRanges object. We can create a GRanges from a data.frame by specifying two of: start, end, or width. df &lt;- data.frame( seqnames=&quot;chr1&quot;, start=1 + c(34e6,36e6,36.6e6), width=c(2e5,2e5,1e5), strand=c(&quot;+&quot;,&quot;-&quot;,&quot;-&quot;), range_id=factor(c(&quot;foo&quot;,&quot;bar&quot;,&quot;boo&quot;))) r &lt;- as_granges(df) r ## GRanges object with 3 ranges and 1 metadata column: ## seqnames ranges strand | range_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; ## [1] chr1 34000001-34200000 + | foo ## [2] chr1 36000001-36200000 - | bar ## [3] chr1 36600001-36700000 - | boo ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths In case you haven’t seen this before, GRanges objects have specific functions to pull out information. See ?GRanges for details. length(r) ## [1] 3 seqnames(r) ## factor-Rle of length 3 with 1 run ## Lengths: 3 ## Values : chr1 ## Levels(1): chr1 strand(r) ## factor-Rle of length 3 with 2 runs ## Lengths: 1 2 ## Values : + - ## Levels(3): + - * Let’s find which genes overlap a region of interest. We will load the Ensembl genes, here from a Bioconductor data package (usually we would obtain these from AnnotationHub). The last lines use convenience functions to convert to, e.g. \"chr1\", …, \"chrY\". library(TxDb.Hsapiens.UCSC.hg19.knownGene) g &lt;- genes(TxDb.Hsapiens.UCSC.hg19.knownGene) ## 403 genes were dropped because they have exons located on both strands ## of the same reference sequence or on more than one reference sequence, ## so cannot be represented by a single genomic range. ## Use &#39;single.strand.genes.only=FALSE&#39; to get all the genes in a ## GRangesList object, or use suppressMessages() to suppress this message. g &lt;- keepStandardChromosomes(g, pruning.mode=&quot;coarse&quot;) Now we are ready to test for overlaps. A left join gives us all the overlaps for ranges on the left side (here r). If a range on the left has no overlaps it appears with NA for the metadata columns of the right side ranges. If a range on the left side has multiple overlaps with the right side, it will appear multiple times in the output. More below on how to deal with this, if it is desired to have statistics on per-range overlaps. r %&gt;% join_overlap_left(g) ## GRanges object with 10 ranges and 2 metadata columns: ## seqnames ranges strand | range_id gene_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;character&gt; ## [1] chr1 34000001-34200000 + | foo 114784 ## [2] chr1 36000001-36200000 - | bar 127703 ## [3] chr1 36000001-36200000 - | bar 23154 ## [4] chr1 36000001-36200000 - | bar 339488 ## [5] chr1 36000001-36200000 - | bar 5690 ## [6] chr1 36000001-36200000 - | bar 63967 ## [7] chr1 36000001-36200000 - | bar 79932 ## [8] chr1 36600001-36700000 - | boo 27095 ## [9] chr1 36600001-36700000 - | boo 55700 ## [10] chr1 36600001-36700000 - | boo 9967 ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths If we want to exclude the zero matches cases, we can use an inner join: r %&gt;% join_overlap_inner(g) ## GRanges object with 10 ranges and 2 metadata columns: ## seqnames ranges strand | range_id gene_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;character&gt; ## [1] chr1 34000001-34200000 + | foo 114784 ## [2] chr1 36000001-36200000 - | bar 127703 ## [3] chr1 36000001-36200000 - | bar 23154 ## [4] chr1 36000001-36200000 - | bar 339488 ## [5] chr1 36000001-36200000 - | bar 5690 ## [6] chr1 36000001-36200000 - | bar 63967 ## [7] chr1 36000001-36200000 - | bar 79932 ## [8] chr1 36600001-36700000 - | boo 27095 ## [9] chr1 36600001-36700000 - | boo 55700 ## [10] chr1 36600001-36700000 - | boo 9967 ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths We can also perform summarization by columns either in the r or the g object: r %&gt;% join_overlap_inner(g) %&gt;% group_by(range_id) %&gt;% summarize(count=n()) ## DataFrame with 3 rows and 2 columns ## range_id count ## &lt;factor&gt; &lt;integer&gt; ## 1 bar 6 ## 2 boo 3 ## 3 foo 1 This is giving us the same information as the following: r %&gt;% count_overlaps(g) ## [1] 1 6 3 Which can be added to the range data with a mutate call: r %&gt;% mutate(overlaps = count_overlaps(., g)) ## GRanges object with 3 ranges and 2 metadata columns: ## seqnames ranges strand | range_id overlaps ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;integer&gt; ## [1] chr1 34000001-34200000 + | foo 1 ## [2] chr1 36000001-36200000 - | bar 6 ## [3] chr1 36600001-36700000 - | boo 3 ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths If we don’t care about multiple overlaps, but just want a binary variable that records if there was one or more overlaps or not, we can ask if the count of overlaps is greater than 0: r %&gt;% mutate(overlaps_any = count_overlaps(., g) &gt; 0) ## GRanges object with 3 ranges and 2 metadata columns: ## seqnames ranges strand | range_id overlaps_any ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;logical&gt; ## [1] chr1 34000001-34200000 + | foo TRUE ## [2] chr1 36000001-36200000 - | bar TRUE ## [3] chr1 36600001-36700000 - | boo TRUE ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths If we want to keep the information about the gene ranges, we swap the order of the ranges in the command: g %&gt;% join_overlap_inner(r) ## GRanges object with 10 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id range_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;factor&gt; ## 114784 chr1 33979609-34631443 - | 114784 foo ## 127703 chr1 36179477-36184790 - | 127703 bar ## 23154 chr1 36023393-36032380 + | 23154 bar ## 27095 chr1 36602170-36621654 - | 27095 boo ## 339488 chr1 36038971-36060927 + | 339488 bar ## 55700 chr1 36621803-36646441 + | 55700 boo ## 5690 chr1 36035413-36107445 - | 5690 bar ## 63967 chr1 36197713-36235551 - | 63967 bar ## 79932 chr1 35899091-36023551 - | 79932 bar ## 9967 chr1 36690017-36770957 + | 9967 boo ## ------- ## seqinfo: 25 sequences (1 circular) from hg19 genome If we want strand specific overlaps, we can add _directed: g %&gt;% join_overlap_inner_directed(r) ## GRanges object with 5 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id range_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;factor&gt; ## 127703 chr1 36179477-36184790 - | 127703 bar ## 27095 chr1 36602170-36621654 - | 27095 boo ## 5690 chr1 36035413-36107445 - | 5690 bar ## 63967 chr1 36197713-36235551 - | 63967 bar ## 79932 chr1 35899091-36023551 - | 79932 bar ## ------- ## seqinfo: 25 sequences (1 circular) from hg19 genome By turning the join around, we have access to the genomic range information about the genes. Now we can compute, e.g. the average genomic extent of the genes (first base to last base), per overlapping range. g %&gt;% join_overlap_inner_directed(r) %&gt;% group_by(range_id) %&gt;% summarize(count=n(), mean_width=mean(width)) ## DataFrame with 2 rows and 3 columns ## range_id count mean_width ## &lt;factor&gt; &lt;integer&gt; &lt;numeric&gt; ## 1 bar 4 59911.8 ## 2 boo 1 19485.0 What about \"boo\"? We need to add a complete() call to account for the fact that we are missing those overlaps after the join. We need to call the function explicitly from the tidyr package but by not loading the package we can avoid some function name conflicts with plyranges. Also we need to convert to tibble (explanation follows). library(tibble) g %&gt;% join_overlap_inner_directed(r) %&gt;% group_by(range_id) %&gt;% summarize(count=n(), mean_width=mean(width)) %&gt;% as_tibble() %&gt;% tidyr::complete(range_id, fill=list(count=0)) ## # A tibble: 3 × 3 ## range_id count mean_width ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 bar 4 59912. ## 2 boo 1 19485 ## 3 foo 0 NA Why did we have to convert to tibble before running complete()? This is because metadata columns of GRanges objects are in a format called DataFrame which the tidyr / dplyr functions don’t know how to operate on. To access these metadata columns, you can use any of these types of calls: mcols(r) ## DataFrame with 3 rows and 1 column ## range_id ## &lt;factor&gt; ## 1 foo ## 2 bar ## 3 boo mcols(r)$range_id ## [1] foo bar boo ## Levels: bar boo foo r$range_id # this works also ## [1] foo bar boo ## Levels: bar boo foo mcols(r)[[&quot;range_id&quot;]] # for programmatic access ## [1] foo bar boo ## Levels: bar boo foo But if you want to work on them in with tidyr / dplyr, you need to first convert to tibble (or data.frame): mcols(r) %&gt;% as_tibble() ## # A tibble: 3 × 1 ## range_id ## &lt;fct&gt; ## 1 foo ## 2 bar ## 3 boo "],["tissue-specific-promoter-marks.html", "Chapter 3 Tissue-specific promoter marks", " Chapter 3 Tissue-specific promoter marks Objective: determine if tissue-specific promoter marks (e.g. H3K27ac) are often near genes that are expressed in a tissue-specific manner. We will load expression data from the GTEx project (Lonsdale and others 2013), which gives median expression in TPM for each tissue. We will use H3K27ac ChIP-seq data from the ENCODE project (Dunham and others 2012). library(tidyr) file &lt;- &quot;data/GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_median_tpm.gct.gz&quot; gtex &lt;- read.delim(file, skip=2) We select two tissues, bladder and kidney, and convert the data from a wide format into a tidy format. tissues &lt;- gtex %&gt;% dplyr::select(Name, Bladder, Kidney...Cortex) %&gt;% dplyr::rename(gene = Name, Kidney = Kidney...Cortex) %&gt;% dplyr::mutate(gene = sub(&quot;\\\\..*&quot;,&quot;&quot;,gene)) %&gt;% pivot_longer(!gene, names_to=&quot;tissue&quot;, values_to=&quot;tpm&quot;) Now define two vectors of genes that are specific to bladder and kidney: bladder_expr &lt;- tissues %&gt;% dplyr::filter(tissue == &quot;Bladder&quot; &amp; tpm &gt; 10) %&gt;% dplyr::pull(gene) kidney_expr &lt;- tissues %&gt;% dplyr::filter(tissue == &quot;Kidney&quot; &amp; tpm &gt; 10) %&gt;% dplyr::pull(gene) int &lt;- intersect(bladder_expr, kidney_expr) bladder_expr &lt;- setdiff(bladder_expr, int) kidney_expr &lt;- setdiff(kidney_expr, int) Next, use an existing TxDb to locate these genes in the genomes. While we usually recommend to use GENCODE genes for human analysis, because the ENCODE chromatin modification peak files on AnnotationHub are in hg19, we use the UCSC hg19 genes here for simplicity of the code: library(TxDb.Hsapiens.UCSC.hg19.knownGene) library(org.Hs.eg.db) Add the ENSEMBL ID and pull out the two tissue-specific sets. g &lt;- genes(TxDb.Hsapiens.UCSC.hg19.knownGene) ## 403 genes were dropped because they have exons located on both strands ## of the same reference sequence or on more than one reference sequence, ## so cannot be represented by a single genomic range. ## Use &#39;single.strand.genes.only=FALSE&#39; to get all the genes in a ## GRangesList object, or use suppressMessages() to suppress this message. library(plyranges) g &lt;- g %&gt;% mutate(ensembl = mapIds(org.Hs.eg.db, gene_id, &quot;ENSEMBL&quot;, &quot;ENTREZID&quot;)) bladder_g &lt;- g %&gt;% filter(ensembl %in% bladder_expr) kidney_g &lt;- g %&gt;% filter(ensembl %in% kidney_expr) Finally we combine the two sets with bind_ranges, and we change the feature size from the whole gene extent (the range from the leftmost exon to rightmost exon), to just the TSS, using anchor_5p and mutate. tss &lt;- bind_ranges(bladder=bladder_g, kidney=kidney_g, .id=&quot;gtissue&quot;) %&gt;% anchor_5p() %&gt;% mutate(width=1) Now we will obtain the H3K27ac peak sets: library(AnnotationHub) ah &lt;- AnnotationHub() # query(ah, c(&quot;Homo sapiens&quot;, &quot;bladder&quot;, &quot;H3K27ac&quot;, &quot;narrowPeak&quot;)) bladder_pks &lt;- ah[[&quot;AH44180&quot;]] # query(ah, c(&quot;Homo sapiens&quot;, &quot;kidney&quot;, &quot;H3K27ac&quot;, &quot;narrowPeak&quot;)) kidney_pks &lt;- ah[[&quot;AH43443&quot;]] save(bladder_pks, kidney_pks, file=&quot;data/peaks.rda&quot;) We download these and scale so they have the same 90% quantile of signalValue. ninety &lt;- function(x) quantile(x, .9, names=FALSE) bladder_pks &lt;- bladder_pks %&gt;% mutate(signal = signalValue / ninety(signalValue)) kidney_pks &lt;- kidney_pks %&gt;% mutate(signal = signalValue / ninety(signalValue)) Combine the peaks from bladder and kidney, filter to those with &lt; 0.1% FDR, and center the peak on the summit (the peak column gives the shift from the left side to the summit). pks &lt;- bind_ranges(bladder=bladder_pks, kidney=kidney_pks, .id=&quot;ptissue&quot;) %&gt;% filter(qValue &gt; 3, width &lt;= 1000) %&gt;% mutate(start = start + peak) %&gt;% select(-peak) %&gt;% mutate(width = 1) Finally, once we have two tidy range sets, we can perform the analysis by a join, followed by two lines that take care of multiple overlaps, followed by two lines that give us our tallies of interest. It appears that tissue-specific peaks are enriched near the tissue-specific genes for both bladder and kidney. tss %&gt;% join_overlap_left(pks, maxgap=500) %&gt;% group_by(ptissue) %&gt;% # within peak tissue... filter(!duplicated(gene_id)) %&gt;% # ...just take the first overlap per gene group_by(gtissue, ptissue) %&gt;% summarize(count = n()) ## DataFrame with 6 rows and 3 columns ## gtissue ptissue count ## &lt;Rle&gt; &lt;character&gt; &lt;integer&gt; ## 1 bladder bladder 2175 ## 2 bladder kidney 1579 ## 3 bladder NA 863 ## 4 kidney bladder 103 ## 5 kidney kidney 208 ## 6 kidney NA 243 The above number could also be found with four countOverlaps calls, by considering all four pairs of overlaps of the two sets of genes and peaks. Another way to avoid counting overlaps more than once per gene is to use the plyranges function, n_distinct(): tss %&gt;% join_overlap_left(pks, maxgap=500) %&gt;% group_by(gtissue, ptissue) %&gt;% summarize(count = n_distinct(gene_id)) ## DataFrame with 6 rows and 3 columns ## gtissue ptissue count ## &lt;Rle&gt; &lt;character&gt; &lt;integer&gt; ## 1 bladder bladder 2175 ## 2 bladder kidney 1579 ## 3 bladder NA 863 ## 4 kidney bladder 103 ## 5 kidney kidney 208 ## 6 kidney NA 243 If we want more information per gene, e.g. suppose we want to compute the average signal per gene of peaks nearby, we need to group twice, once also by gene ID, and the second time integrating over gene ID. While here we add a few more lines of code, performing such an operation with base Bioconductor functions would require adding code to perform the loops, adding many intermediate variables to store results, etc. tss %&gt;% join_overlap_left(pks, maxgap=500) %&gt;% group_by(gtissue, ptissue, gene_id) %&gt;% # need per gene stats summarize(num_overlaps = n(), signal = mean(signal)) %&gt;% as_tibble() %&gt;% # DataFrame to tibble for further processing group_by(gtissue, ptissue) %&gt;% summarize(sum_any_overlaps = sum(num_overlaps &gt; 0), mean_signal=mean(signal)) ## `summarise()` has grouped output by &#39;gtissue&#39;. You can override using the ## `.groups` argument. ## # A tibble: 6 × 4 ## # Groups: gtissue [2] ## gtissue ptissue sum_any_overlaps mean_signal ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 bladder bladder 2175 1.18 ## 2 bladder kidney 1579 0.929 ## 3 bladder &lt;NA&gt; 863 NA ## 4 kidney bladder 103 0.991 ## 5 kidney kidney 208 0.714 ## 6 kidney &lt;NA&gt; 243 NA What’s wrong with this analysis? We didn’t figure out the expressed promoter, we just looked at the left or rightmost isoform (for + or - strand genes, respectively). References "],["bootstrap-overlap.html", "Chapter 4 Bootstrap overlap", " Chapter 4 Bootstrap overlap Objective: determine if one set of peaks are overlapping another set of peaks more or less than expected when comparing to sets of null features. The null features can be generated in a variety of ways – here we will generate them by resampling large blocks of one of the peak sets. The motivation for sampling blocks, instead of placing features uniformly along the chromosome (“shuffling”), is to better preserve inter-feature distances, because genomic features tend to cluster in the genome, even after considering things like excluded regions. This technique of generating null feature sets is called block bootstrap resampling, and we will use the nullranges implementation of the block bootstrapping algorithm to generate the null features, followed by overlap analysis with plyranges. The approach used in nullranges to generate bootstrap ranges closely follows the method described by Bickel et al. (2010). We start by loading the ENCODE kidney and bladder H3K27ac ChIP-seq peaks used in the previous analysis (Dunham and others 2012). library(AnnotationHub) ah &lt;- AnnotationHub() kidney_pks &lt;- ah[[&quot;AH43443&quot;]] bladder_pks &lt;- ah[[&quot;AH44180&quot;]] We will additionally obtain an excluded region set, so that we avoid placing bootstrap features into regions of the genome that don’t typically have features. A variety of possible exclude lists are provided by the excluderanges packages and available via AnnotationHub. Here we will use the hg19.Crawford.wgEncodeDukeMapabilityRegionsExcludable regions, as they are available for hg19, which is the genome used with the peak sets. # query(ah, c(&quot;excluderanges&quot;,&quot;hg19&quot;)) exclude &lt;- ah[[&quot;AH95912&quot;]] save(&quot;data/exclude.rda&quot;) To make the code more generic, we will rename the kidney peaks to x and the bladder peaks to y. We will be looking for overlaps with features in x as the query set: how many of the features in x overlap features in y? The following code reduces our analysis to looking only at standard chromosomes, excluding the mitochondrial genome (too small for including in the block bootstrap). library(GenomeInfoDb) x &lt;- kidney_pks y &lt;- bladder_pks x &lt;- keepStandardChromosomes(x) seqlevels(x, pruning.mode=&quot;coarse&quot;) &lt;- setdiff(seqlevels(x), &quot;chrM&quot;) seqlevels(y, pruning.mode=&quot;coarse&quot;) &lt;- seqlevels(x) seqlevels(exclude, pruning.mode=&quot;coarse&quot;) &lt;- seqlevels(x) We are mostly concerned with avoiding placing bootstrapped features in large regions in the exclude list, so we subset the exclude list to features larger than 500 bp. Why do we have plyranges:: in front of filter? This is because there is a function in the ensembldb package that is also called filter, so it’s a bit safer if we are using both packages to use the package name. library(plyranges) exclude &lt;- exclude %&gt;% plyranges::filter(width(exclude) &gt;= 500) We also subset to the peaks for kidney and bladder which have q-value less than 0.001 and signal value greater than 9 (these are arbitrary filter values, just for demonstration). For further analysis, we will need the features in y to be sorted, for the bootstrapping, here we sort both sets. q_thr &lt;- 3 s_thr &lt;- 9 x &lt;- x %&gt;% plyranges::filter(qValue &gt; q_thr &amp; signalValue &gt; s_thr) %&gt;% sort() y &lt;- y %&gt;% plyranges::filter(qValue &gt; q_thr &amp; signalValue &gt; s_thr) %&gt;% sort() Now we can assess how many overlaps we observed between x and y: obs &lt;- x %&gt;% mutate(n_overlaps = count_overlaps(., y)) obs %&gt;% summarize(total = sum(n_overlaps)) ## DataFrame with 1 row and 1 column ## total ## &lt;integer&gt; ## 1 5073 table( obs$n_overlaps ) ## ## 0 1 2 3 4 6 ## 9453 3966 486 39 3 1 We can check if any of the features of y fall in the excluded regions: y %&gt;% mutate(n_overlaps = count_overlaps(., exclude)) %&gt;% summarize(total = sum(n_overlaps)) ## DataFrame with 1 row and 1 column ## total ## &lt;integer&gt; ## 1 0 The following chunk of code does the bootstrapping of features in y. Here we subset first to metadata columns of interest (an id variable that we create, and the signal value which we rename to signal). pks_to_boot &lt;- y %&gt;% mutate(id = seq_along(y)) %&gt;% plyranges::select(id, signal = signalValue) The bootRanges function returns the bootstrap feature sets combined into one GRanges object – this tidy format facilitates downstream analysis as we will see. The bootstrap iteration is stored in the iter metadata column. library(nullranges) R &lt;- 30 # number of iterations set.seed(5) # set seed for reproducibility boots &lt;- bootRanges(pks_to_boot, blockLength=5e5, R=R, exclude=exclude) boots ## BootRanges object with 174764 ranges and 5 metadata columns: ## seqnames ranges strand | id signal block ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt; ## [1] chr1 2011397-2011809 * | 931 14.42934 5 ## [2] chr1 2011973-2012399 * | 932 17.57052 5 ## [3] chr1 2012505-2013073 * | 933 9.64691 5 ## [4] chr1 2503670-2505748 * | 3752 20.84181 6 ## [5] chr1 2505855-2507134 * | 3753 15.29241 6 ## ... ... ... ... . ... ... ... ## [174760] chrY 57499850-57501632 * | 5141 10.09210 6202 ## [174761] chrY 57937341-57937960 * | 1062 15.98656 6203 ## [174762] chrY 58145916-58146540 * | 264 15.23097 6204 ## [174763] chrY 58146662-58147585 * | 265 12.26661 6204 ## [174764] chrY 58214091-58214746 * | 266 9.69322 6204 ## iter blockLength ## &lt;Rle&gt; &lt;Rle&gt; ## [1] 1 500000 ## [2] 1 500000 ## [3] 1 500000 ## [4] 1 500000 ## [5] 1 500000 ## ... ... ... ## [174760] 30 500000 ## [174761] 30 500000 ## [174762] 30 500000 ## [174763] 30 500000 ## [174764] 30 500000 ## ------- ## seqinfo: 24 sequences from hg19 genome The default use above of the exclude argument is to drop bootstrapped ranges that overlap the exclude list. We can examine properties of permuted y over iterations, and compare to the original y. To do so, we first add the original features as iter=0. combined &lt;- pks_to_boot %&gt;% mutate(iter=0) %&gt;% bind_ranges(boots) %&gt;% plyranges::select(iter) Then compute summaries: library(tibble) stats &lt;- combined %&gt;% group_by(iter) %&gt;% summarize(n = n(), sum_width=sum(width)/1e6) %&gt;% as_tibble() Original y vs bootstrap: stats[1,] ## # A tibble: 1 × 3 ## iter n sum_width ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 0 5838 5.07 summary(stats[-1,]) ## iter n sum_width ## 1 : 1 Min. :5595 Min. :4.843 ## 2 : 1 1st Qu.:5723 1st Qu.:4.968 ## 3 : 1 Median :5825 Median :5.042 ## 4 : 1 Mean :5825 Mean :5.057 ## 5 : 1 3rd Qu.:5910 3rd Qu.:5.130 ## 6 : 1 Max. :6053 Max. :5.295 ## (Other):24 We can also look at distributions of various aspects, e.g. here the width of features, across a few of the bootstraps and the original feature set y. library(ggplot2) library(ggridges) combined %&gt;% plyranges::filter(iter %in% 0:5) %&gt;% plyranges::select(iter) %&gt;% as_tibble() %&gt;% mutate(type = ifelse(iter == 0, &quot;original&quot;, &quot;boot&quot;)) %&gt;% ggplot(aes(log10(width), iter, fill=type)) + geom_density_ridges(alpha = 0.75) + geom_text(data=head(stats), aes(x=2.25, y=iter, label=paste0(&quot;n=&quot;,n), fill=NULL), vjust=1.5) To compute overlap with the null features, we need the complete() function from the tidyr package. We saw complete() before – this is used in the case that one of the iterations has no overlaps. In this case, we need to record the 0 value for proper inference and plots downstream. It is rare we would have no overlaps with so many features as we have in x and y but it’s good practice to leave the complete() as part of the workflow so the code works correctly in all cases. The overlap per iteration of the bootstrap is accomplished by a series of plyranges / dplyr commands (we switch to dplyr halfway through, after the as_tibble() call). library(tidyr) null &lt;- x %&gt;% join_overlap_inner(boots) %&gt;% group_by(iter) %&gt;% summarize(n_overlaps = n()) %&gt;% as_tibble() %&gt;% complete(iter, fill=list(n_overlaps = 0)) head(null) ## # A tibble: 6 × 2 ## iter n_overlaps ## &lt;fct&gt; &lt;int&gt; ## 1 1 60 ## 2 2 60 ## 3 3 76 ## 4 4 51 ## 5 5 39 ## 6 6 66 sum( obs$n_overlaps ) ## [1] 5073 The observed number of overlaps is about two orders of magnitude more than the bootstrapped number, which makes sense as two tissues would be expected to share a number of similar regulatory regions (as marked by H3K27ac) – more so than randomly placed genomic features, even after accounting for excluded regions and feature clustering. ggplot(null, aes(n_overlaps)) + geom_histogram(binwidth=5) + ggtitle(&quot;bootstrap overlaps&quot;) What could be improved with this analysis? Note that in the above chunks where we count overlaps, we are doubly (or triply, etc.) counting features in x if they hit more than one feature in y or boots. We can count statistics per x feature by adding another group_by into the stream of operations. This also allows us to do more complex operations, such as computing the maximum signal value for the overlapping features in y per feature in x: First add an ID variable to keep track of x features: x &lt;- x %&gt;% mutate(x_id = seq_along(x)) Then perform an inner join, and group by the new x ID: obs &lt;- x %&gt;% join_overlap_inner(pks_to_boot) %&gt;% group_by(x_id) %&gt;% summarize(num_overlaps = n(), max_signal = max(signal)) sum( obs$num_overlaps &gt; 0 ) ## [1] 4495 summary( obs$max_signal ) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 9.002 10.281 12.025 13.029 14.725 35.211 For the bootstrap ranges overlap step, we also need to add iter to the initial group_by, so we count per x feature and per iteration of the bootstrap: null &lt;- x %&gt;% join_overlap_inner(boots) %&gt;% group_by(x_id, iter) %&gt;% summarize(num_overlaps = n()) %&gt;% as_tibble() %&gt;% group_by(iter) %&gt;% summarize(any_hits = sum(num_overlaps &gt; 0)) %&gt;% complete(iter, fill=list(any_hits = 0)) head(null) ## # A tibble: 6 × 2 ## iter any_hits ## &lt;fct&gt; &lt;int&gt; ## 1 1 55 ## 2 2 55 ## 3 3 68 ## 4 4 50 ## 5 5 37 ## 6 6 63 Still, we are seeing much more overlap in the observed data than in the bootstrap data: sum( obs$num_overlaps &gt; 0 ) / mean(null$any_hits) ## [1] 76.75014 The above code chunk then avoids double counting. We could also have made other per-x-feature statistics in the summarize step after the initial group_by, such as maximum signal of overlapping features. What other ways could we have done this analysis? Suppose we don’t just want the count of overlaps, but the rate of overlaps from the y perspective, keeping track of the variable number of features per bootstrap. We demonstrate one approach to obtain this rate for the bootstraps: x_thin &lt;- x %&gt;% plyranges::select(x_id) null &lt;- boots %&gt;% plyranges::select(id, iter) %&gt;% join_overlap_inner(x_thin) %&gt;% group_by(id, iter) %&gt;% summarize(num_overlaps = n()) %&gt;% as_tibble() %&gt;% group_by(iter) %&gt;% summarize(any_hits = sum(num_overlaps &gt; 0)) %&gt;% complete(iter, fill=list(any_hits = 0)) Now combine with the per-iteration total count: totals &lt;- boots %&gt;% group_by(iter) %&gt;% summarize(total=n()) %&gt;% as_tibble() null %&gt;% dplyr::left_join(totals) %&gt;% mutate(rate = any_hits/total) ## Joining, by = &quot;iter&quot; ## # A tibble: 30 × 4 ## iter any_hits total rate ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 59 6031 0.00978 ## 2 2 58 5710 0.0102 ## 3 3 73 5758 0.0127 ## 4 4 50 5927 0.00844 ## 5 5 37 5713 0.00648 ## 6 6 59 5888 0.0100 ## 7 7 58 5910 0.00981 ## 8 8 79 5836 0.0135 ## 9 9 59 5770 0.0102 ## 10 10 50 5991 0.00835 ## # … with 20 more rows References "],["snp-position-in-peaks.html", "Chapter 5 SNP position in peaks", " Chapter 5 SNP position in peaks Objective: determine the position of a set of SNPs in peaks, that is, determine the relative positions of those SNPs that overlap the peaks. We again will use the ENCODE kidney H3K27ac ChIP-seq peaks used in the previous analysis (Dunham and others 2012). We will create some artificial SNPs: this analysis could generalize to any time that we have two ranges, where we are interested in the relative position of one set of ranges (SNPs) within the other set of ranges (peaks). library(AnnotationHub) ah &lt;- AnnotationHub() kidney_pks &lt;- ah[[&quot;AH43443&quot;]] We will filter the peaks to standard chromosomes, and include the same cutoffs we used in the previous analysis. suppressPackageStartupMessages(library(GenomeInfoDb)) pks &lt;- kidney_pks pks &lt;- keepStandardChromosomes(pks) ## Loading required package: GenomicRanges suppressPackageStartupMessages({ library(dplyr) library(tibble) library(plyranges) }) q_thr &lt;- 3 s_thr &lt;- 9 pks &lt;- pks %&gt;% filter(qValue &gt; q_thr &amp; signalValue &gt; s_thr) %&gt;% sort() A histogram of peak width: library(ggplot2) pks %&gt;% as_tibble %&gt;% filter(width &lt; 5000) %&gt;% ggplot(aes(width)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Let’s subset to peaks that are less than 2000 in width: pks &lt;- pks %&gt;% filter(width &lt; 2000) Now, we may be interested in SNPs that are associated with regulatory function. While we could find these from a database of chromatin QTL or functionally validated variants, here we will just create a simulated set of SNPs for demonstration. set.seed(1) snps &lt;- pks %&gt;% slice(sample.int(n(), 2000)) %&gt;% anchor_5p() %&gt;% mutate(start=start + floor(runif(n(),0,width))) %&gt;% mutate(width=1) snps ## GRanges object with 2000 ranges and 6 metadata columns: ## seqnames ranges strand | name score signalValue ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; ## [1] chr1 222886667 * | Rank_786 943 28.06788 ## [2] chr17 1251302 * | Rank_11154 238 10.45065 ## [3] chr9 75179753 * | Rank_8060 305 12.52016 ## [4] chrX 70401571 * | Rank_9602 266 11.38197 ## [5] chr20 37615472 * | Rank_14922 190 9.52741 ## ... ... ... ... . ... ... ... ## [1996] chr9 14316343 * | Rank_15136 188 9.11715 ## [1997] chr18 74800298 * | Rank_15685 181 9.02626 ## [1998] chr19 52641902 * | Rank_2464 606 19.64891 ## [1999] chr2 128642862 * | Rank_15514 184 9.18719 ## [2000] chr6 151005236 * | Rank_13672 203 9.07738 ## pValue qValue peak ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## [1] 94.3437 89.9679 267 ## [2] 23.8843 21.0424 458 ## [3] 30.5751 27.5376 616 ## [4] 26.6991 23.7679 455 ## [5] 19.0203 16.3297 414 ## ... ... ... ... ## [1996] 18.8452 16.1647 461 ## [1997] 18.1808 15.5192 173 ## [1998] 60.6790 56.9445 1281 ## [1999] 18.4512 15.7837 125 ## [2000] 20.3511 17.6170 887 ## ------- ## seqinfo: 25 sequences (1 circular) from hg19 genome These should all overlap peaks: snps %&gt;% mutate(n_overlaps = count_overlaps(., pks)) %&gt;% summarize(tab=table(n_overlaps)) ## DataFrame with 1 row and 2 columns ## tab.n_overlaps tab.Freq ## &lt;factor&gt; &lt;integer&gt; ## 1 1 2000 We now have a bit of a hack for this analysis: we add the start position and width of the peak as addition columns of metadata. This is because otherwise, we will lose the start position when we perform the overlap of SNPs in peaks, and we need it for later. pks_trim &lt;- pks %&gt;% select(name) %&gt;% mutate(peak_start=start, peak_width=width) We can then obtain overlaps of SNPs with peaks, and add the relative position of the SNP within the peak extent. We use 1-based indexing, such that if the SNP is the same as the leftmost basepair of the peak, it gets counted as position 1. o &lt;- snps %&gt;% join_overlap_inner(pks_trim) %&gt;% mutate(rel_pos = start - peak_start + 1, rel_frac = (rel_pos - 1) / (peak_width - 1 )) Check our expectations about these new columns: all(o$rel_pos &gt;= 1) ## [1] TRUE all(o$rel_frac &gt;= 0) ## [1] TRUE all(o$rel_frac &lt;= 1) ## [1] TRUE Finally, we can compute a histogram of where the SNPs fall in the peaks: o %&gt;% as_tibble() %&gt;% ggplot(aes(rel_frac)) + geom_histogram(breaks=0:10/10) Now stratifying by width of peak: quantile(o$peak_width, 0:3/3) ## 0% 33.33333% 66.66667% 100% ## 246.0000 813.3333 1289.6667 1998.0000 o %&gt;% mutate(width_bin = cut(peak_width, breaks=c(200,800,1300,2000), include.lowest=TRUE)) %&gt;% as_tibble() %&gt;% ggplot(aes(rel_frac)) + geom_histogram(breaks=0:10/10) + facet_wrap(~width_bin) References "],["tidy-gene-plots.html", "Chapter 6 Tidy gene plots", " Chapter 6 Tidy gene plots Objective: for a region of the genome, find peaks near the TSS of genes and then plot their signal strength per gene, stratifying by the tissue origin of the peak. We start by loading the pre-downloaded peaks ranges: load(&quot;data/peaks.rda&quot;) Likewise, we want to use hg19 genes again to match the hg19 peaks: library(TxDb.Hsapiens.UCSC.hg19.knownGene) library(org.Hs.eg.db) g &lt;- genes(TxDb.Hsapiens.UCSC.hg19.knownGene) Adding gene symbols: library(plyranges) g &lt;- g %&gt;% mutate(gene_name = mapIds(org.Hs.eg.db, gene_id, &quot;SYMBOL&quot;, &quot;ENTREZID&quot;)) Find a region of the genome near a kidney-specific gene: g %&gt;% filter(gene_name == &quot;UMOD&quot;) ## GRanges object with 1 range and 2 metadata columns: ## seqnames ranges strand | gene_id gene_name ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; ## 7369 chr16 20344373-20364037 - | 7369 UMOD ## ------- ## seqinfo: 93 sequences (1 circular) from hg19 genome region &lt;- data.frame( seqnames=&quot;chr16&quot;, start=20e6, end=21e6) %&gt;% as_granges() Combine the bladder and kidney peaks, and select certain columns: pks &lt;- bind_ranges(bladder=bladder_pks, kidney=kidney_pks, .id=&quot;tissue&quot;) %&gt;% select(signal=signalValue, tissue) Finally, we perform the overlap join, locating peaks within 100kb of the TSS of the gene. g_with_pks &lt;- g %&gt;% anchor_5p() %&gt;% mutate(width=1) %&gt;% filter_by_overlaps(region) %&gt;% join_overlap_inner(pks, maxgap=1e5) g_with_pks$tissue %&gt;% table() ## . ## bladder kidney ## 208 337 We can construct a faceted set of boxplots, first we make a tibble of data for our plot. library(dplyr) library(tibble) dat &lt;- g_with_pks %&gt;% select(gene_name, signal, tissue, .drop_ranges=TRUE) %&gt;% as_tibble() Then pass the data to ggplot (we could have just passed the data directly, but we plan to re-use the data). library(ggplot2) dat %&gt;% ggplot(aes(tissue, signal)) + geom_boxplot() + facet_wrap(~gene_name) Now let’s try to plot these in context, using plotgardener (Kramer et al. 2022). First we filter down to the peaks near UMOD. umod &lt;- g %&gt;% filter(gene_name == &quot;UMOD&quot;) %&gt;% anchor_5p() %&gt;% mutate(width=1) pks_to_plot &lt;- pks %&gt;% filter_by_overlaps(umod, maxgap=1e5) %&gt;% anchor_center() %&gt;% mutate(width=1e4) # to make the ranges more visible We then define a color scheme for the tissue variable, and make a ggplot object which will be added to our genome plots. cols &lt;- function(n) palette.colors(n+2)[-c(1,3)] col_vec &lt;- cols(2) names(col_vec) &lt;- unique(dat$tissue) p &lt;- dat %&gt;% filter(gene_name == &quot;UMOD&quot;) %&gt;% ggplot(aes(tissue, signal, col=tissue)) + # here we set a seed for jitter geom_point(size=.5, position=position_jitter(width=.1, seed=5)) + scale_color_manual(values = col_vec) We then create some parameters that will be shared across a number of the plots in plotgardener. library(plotgardener) par &lt;- pgParams( chrom = &quot;chr16&quot;, chromstart = round((start(umod) - 1e5)/1e5)*1e5, chromend = round((start(umod) + 4e5)/1e5)*1e5, assembly = &quot;hg19&quot;, just = c(&quot;left&quot;, &quot;bottom&quot;) ) Finally we put all the pieces together on a page (for laying out the plot, first use showGuides=TRUE). pageCreate(width = 5, height = 3, showGuides = FALSE) plotGenes( params = par, x = 0.5, y = 2.5, width = 4, height = .75 ) ## genes[genes1] plotRanges( pks_to_plot, fill = colorby(&quot;tissue&quot;, palette=cols), params = par, x = 0.5, y = 1.75, width = 4, height = 1.75 ) ## ranges[ranges1] plotGenomeLabel( params = par, x = 0.5, y = 2.5, length = 4, just = c(&quot;left&quot;, &quot;top&quot;) ) ## genomeLabel[genomeLabel1] plotGG( p + ggtitle(&quot;UMOD&quot;), params = par, x = 2.25, y = 1.75, width = 2.5, height = 1.75 ) ## gg[gg1] References "],["tidy-rna-seq-eda.html", "Chapter 7 Tidy RNA-seq EDA", " Chapter 7 Tidy RNA-seq EDA Objective: learn how to perform EDA of RNA-seq data using tidybulk. library(oct4) dir &lt;- system.file(&quot;extdata&quot;, package=&quot;oct4&quot;) coldata &lt;- read.csv(file.path(dir,&quot;coldata.csv&quot;)) coldata ## names line condition ## 1 SRX2236945 OCT4 untrt ## 2 SRX2236946 OCT4 untrt ## 3 SRX2236947 OCT4 untrt ## 4 SRX2236948 OCT4 trt ## 5 SRX2236949 OCT4 trt ## 6 SRX2236950 OCT4 trt ## 7 SRX2236951 BRG1 untrt ## 8 SRX2236952 BRG1 untrt ## 9 SRX2236953 BRG1 untrt ## 10 SRX2236954 BRG1 trt ## 11 SRX2236955 BRG1 trt ## 12 SRX2236956 BRG1 trt coldata$files &lt;- file.path(dir, &quot;quants&quot;, coldata$names, &quot;quant.sf.gz&quot;) library(tximeta) se &lt;- tximeta(coldata) gse &lt;- summarizeToGene(se) library(org.Mm.eg.db) gse &lt;- addIds(gse, &quot;SYMBOL&quot;) library(SummarizedExperiment) assayNames(gse) assays(gse) &lt;- assays(gse)[1:3] save(gse, file=&quot;data/oct4_obj.rda&quot;) library(SummarizedExperiment) ## Loading required package: MatrixGenerics ## Loading required package: matrixStats ## ## Attaching package: &#39;MatrixGenerics&#39; ## The following objects are masked from &#39;package:matrixStats&#39;: ## ## colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, ## colCounts, colCummaxs, colCummins, colCumprods, colCumsums, ## colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, ## colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, ## colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, ## colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, ## colWeightedMeans, colWeightedMedians, colWeightedSds, ## colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, ## rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, ## rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, ## rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, ## rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, ## rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, ## rowWeightedMads, rowWeightedMeans, rowWeightedMedians, ## rowWeightedSds, rowWeightedVars ## Loading required package: GenomicRanges ## Loading required package: stats4 ## Loading required package: BiocGenerics ## ## Attaching package: &#39;BiocGenerics&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## IQR, mad, sd, var, xtabs ## The following objects are masked from &#39;package:base&#39;: ## ## anyDuplicated, aperm, append, as.data.frame, basename, cbind, ## colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ## get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, ## match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, ## Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, ## table, tapply, union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## ## Attaching package: &#39;S4Vectors&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: GenomeInfoDb ## Loading required package: Biobase ## Welcome to Bioconductor ## ## Vignettes contain introductory material; view with ## &#39;browseVignettes()&#39;. To cite Bioconductor, see ## &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. ## ## Attaching package: &#39;Biobase&#39; ## The following object is masked from &#39;package:MatrixGenerics&#39;: ## ## rowMedians ## The following objects are masked from &#39;package:matrixStats&#39;: ## ## anyMissing, rowMedians load(&quot;data/oct4_obj.rda&quot;) gse$rep &lt;- rep(1:3, 4) colnames(gse) &lt;- paste(gse$line,gse$condition,gse$rep,sep=&quot;-&quot;) assay(gse, &quot;counts&quot;) &lt;- round(assay(gse, &quot;counts&quot;)) # for consistency library(org.Mm.eg.db) ## Loading required package: AnnotationDbi ## # pluripotency tab &lt;- select(org.Mm.eg.db, &quot;GO:0019827&quot;, &quot;SYMBOL&quot;, &quot;GO&quot;) ## &#39;select()&#39; returned 1:many mapping between keys and columns tab &lt;- tab[!duplicated(tab$SYMBOL),] pluri &lt;- tab$SYMBOL library(tidybulk) ## ======================================== ## tidybulk version 1.11.2 ## If you use TIDYBULK in published research, please cite: ## ## Mangiola et al. tidybulk: an R tidy framework for modular ## transcriptomic data analysis. Genome Biology 2021. ## ## This message can be suppressed by: ## suppressPackageStartupMessages(library(tidybulk)) ## ======================================== ## ## Attaching package: &#39;tidybulk&#39; ## The following object is masked from &#39;package:S4Vectors&#39;: ## ## rename ## The following object is masked from &#39;package:stats&#39;: ## ## filter library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:tidybulk&#39;: ## ## bind_cols, bind_rows ## The following object is masked from &#39;package:AnnotationDbi&#39;: ## ## select ## The following object is masked from &#39;package:Biobase&#39;: ## ## combine ## The following objects are masked from &#39;package:GenomicRanges&#39;: ## ## intersect, setdiff, union ## The following object is masked from &#39;package:GenomeInfoDb&#39;: ## ## intersect ## The following objects are masked from &#39;package:IRanges&#39;: ## ## collapse, desc, intersect, setdiff, slice, union ## The following objects are masked from &#39;package:S4Vectors&#39;: ## ## first, intersect, rename, setdiff, setequal, union ## The following objects are masked from &#39;package:BiocGenerics&#39;: ## ## combine, intersect, setdiff, union ## The following object is masked from &#39;package:matrixStats&#39;: ## ## count ## The following object is masked from &#39;package:testthat&#39;: ## ## matches ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(stringr) oct4 &lt;- gse %&gt;% tidybulk() %&gt;% filter(line == &quot;OCT4&quot;) %&gt;% mutate(.sample = str_remove(.sample, &quot;OCT4-&quot;)) %&gt;% mutate(.sample = factor(.sample, levels=unique(.sample)), condition = factor(condition, c(&quot;untrt&quot;,&quot;trt&quot;))) oct4 &lt;- oct4 %&gt;% keep_abundant(factor_of_interest = condition) %&gt;% scale_abundance(method=&quot;RLE&quot;) # DESeq2 scaling ## tidybulk says: the sample with largest library size untrt-1 was chosen as reference for scaling library(ggplot2) oct4 %&gt;% ggplot(aes(.sample, log10(counts_scaled + 1))) + geom_boxplot() library(DESeq2) gse_sub &lt;- gse[ , gse$line == &quot;OCT4&quot; ] gse_sub$condition &lt;- factor(gse_sub$condition) dds &lt;- gse_sub %&gt;% DESeqDataSet(~condition) %&gt;% estimateSizeFactors() ## using counts and average transcript lengths from tximeta ## using &#39;avgTxLength&#39; from assays(dds), correcting for library size boxplot(log10(counts(dds, normalized=TRUE) + 1)) oct4 %&gt;% filter(SYMBOL %in% pluri) %&gt;% mutate(logcounts = log10(counts_scaled + 1)) %&gt;% mutate(Oct4 = ifelse(SYMBOL == &quot;Pou5f1&quot;, &quot;red&quot;, &quot;black&quot;)) %&gt;% group_by(.feature) %&gt;% mutate(logcounts = logcounts - mean(logcounts)) %&gt;% ungroup() %&gt;% ggplot(aes(.sample, logcounts, group=.feature, color=Oct4)) + geom_point() + geom_line() + scale_color_identity() gene_idx &lt;- mcols(dds)$SYMBOL %in% pluri mat &lt;- log10(counts(dds, normalized=TRUE)[gene_idx,] + 1) mat &lt;- mat - rowMeans(mat) hilite &lt;- rownames(dds)[which(mcols(dds)$SYMBOL == &quot;Pou5f1&quot;)] plot(mat[1,], type=&quot;n&quot;, ylim=c(-1,1), xlab=&quot;samples&quot;, ylab=&quot;logcounts&quot;) for (i in 1:nrow(mat)) { col &lt;- ifelse(rownames(mat)[i] == hilite, &quot;red&quot;, &quot;black&quot;) points(mat[i,], type=&quot;b&quot;, col=col) } gene_idx &lt;- oct4 %&gt;% pivot_transcript() %&gt;% pull(.feature) assays(dds) &lt;- assays(dds)[1:2] # compatiblity with tidybulk res &lt;- dds[gene_idx,] %&gt;% DESeq() %&gt;% results() ## estimating size factors ## estimating dispersions ## gene-wise dispersion estimates ## mean-dispersion relationship ## final dispersion estimates ## fitting model and testing oct4 &lt;- oct4 %&gt;% test_differential_abundance(~condition, method=&quot;deseq2&quot;) ## ===================================== ## tidybulk says: All testing methods use raw counts, irrespective of if scale_abundance ## or adjust_abundance have been calculated. Therefore, it is essential to add covariates ## such as batch effects (if applicable) in the formula. ## ===================================== ## estimating size factors ## ## estimating dispersions ## ## gene-wise dispersion estimates ## ## mean-dispersion relationship ## ## final dispersion estimates ## ## fitting model and testing ## ## tidybulk says: to access the raw results (fitted GLM) do `attr(..., &quot;internals&quot;)$DESeq2` ## This message is displayed once per session. tidy_res &lt;- oct4 %&gt;% pivot_transcript() all.equal(rownames(res), tidy_res$.feature) ## [1] TRUE table(base_sig = res$padj &lt; .1, tidy_sig = tidy_res$padj &lt; .1) ## tidy_sig ## base_sig FALSE TRUE ## FALSE 17743 0 ## TRUE 0 3734 plot_data &lt;- oct4 %&gt;% filter(SYMBOL %in% pluri) %&gt;% mutate(logcounts = log10(counts_scaled + 1)) %&gt;% mutate(Oct4 = ifelse(SYMBOL == &quot;Pou5f1&quot;, &quot;red&quot;, &quot;black&quot;)) %&gt;% group_by(.feature) %&gt;% mutate(logcounts = logcounts - mean(logcounts)) %&gt;% ungroup() %&gt;% mutate(gene_type = case_when( padj &lt; .1 &amp; log2FoldChange &gt; 0 ~ &quot;up&quot;, padj &lt; .1 &amp; log2FoldChange &lt; 0 ~ &quot;down&quot;, TRUE ~ &quot;null&quot;)) library(ggrepel) plot_data %&gt;% ggplot(aes(.sample, logcounts, group=.feature, color=Oct4)) + geom_point() + geom_line() + geom_text_repel(data=plot_data %&gt;% filter(.sample == &quot;trt-3&quot;, gene_type != &quot;null&quot;), aes(.sample, logcounts, label=SYMBOL)) + scale_color_identity() + facet_wrap(~gene_type) + scale_x_discrete(expand = expansion(add = 2)) + xlab(&quot;sample&quot;) ## Warning: ggrepel: 8 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
